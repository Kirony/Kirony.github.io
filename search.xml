<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我没奶奶了</title>
      <link href="/posts/c5700d68.html"/>
      <url>/posts/c5700d68.html</url>
      
        <content type="html"><![CDATA[<h1 id="奶奶没了"><a href="#奶奶没了" class="headerlink" title="奶奶没了"></a>奶奶没了</h1><hr><p>我把门关了</p><p>奶奶门关上</p><p>再偷偷开个小缝</p><p>看得到她在的</p><p>像几天前一样</p><p>有呼吸机的声音</p><p>躺在床上翻身呢</p>]]></content>
      
      
      <categories>
          
          <category> 奶奶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奶奶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch笔记</title>
      <link href="/posts/f14ce4db.html"/>
      <url>/posts/f14ce4db.html</url>
      
        <content type="html"><![CDATA[<h1 id="伸缩自如的ElasticSearch——通过bboss操作和访问elasticsearch模式"><a href="#伸缩自如的ElasticSearch——通过bboss操作和访问elasticsearch模式" class="headerlink" title="伸缩自如的ElasticSearch——通过bboss操作和访问elasticsearch模式"></a>伸缩自如的ElasticSearch——通过bboss操作和访问elasticsearch模式</h1><hr><h2 id="ClientUtil"><a href="#ClientUtil" class="headerlink" title="ClientUtil"></a>ClientUtil</h2><p>bboss操作和访问elasticsearch提供两种模式，分别对应两个组件：</p><ul><li><p>RestClientUtil：通用组件，提供所有不依赖dsl的功能，也可以直接接收dsl。</p></li><li><p>ConfigRestClientUtil：加载配置文件中的dsl来实现对es的操作</p></li></ul><p>这两个组件分别通过org.frameworkset.elasticsearch.ElasticSearchHelper中提供的静态工厂方法获取其单实例对象，这些单实例对象是多线程并发安全的，分别说明如下：</p><p><strong>加载配置文件中的dsl来实现对es的操作模式</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClientInterface <span class="title function_">getConfigRestClientUtil</span><span class="params">(String configFile)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClientInterface <span class="title function_">getConfigRestClientUtil</span><span class="params">(String elasticSearch,String configFile)</span> <span class="comment">//elasticsearch参数指定了bboss中多集群配</span></span><br></pre></td></tr></table></figure><br><strong>所有不依赖dsl的功能，或直接接收dsl模式</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClientInterface <span class="title function_">getRestClientUtil</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClientInterface <span class="title function_">getRestClientUtil</span><span class="params">(String elasticSearch)</span> <span class="comment">//elasticsearch参数指定了bboss中多集群配</span></span><br></pre></td></tr></table></figure></p><p>通过这两个方法获取到的ClientInterface实例是多线程安全的、单实例对象。<br>直接操作dsl使用实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectDslQuery</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">queryAll</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;query\&quot;: &#123;\&quot;match_all\&quot;: &#123;&#125;&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="type">ClientInterface</span> <span class="variable">clientUtil</span> <span class="operator">=</span> ElasticSearchHelper.getRestClientUtil();</span><br><span class="line">ESDatas&lt;Demo&gt; esDatas =clientUtil.searchList(<span class="string">&quot;demo/_search&quot;</span>,<span class="comment">//demo为索引表，_search为检索操作action</span></span><br><span class="line">queryAll,<span class="comment">//queryAll变量对应的dsl语句</span></span><br><span class="line">Demo.class);</span><br><span class="line"><span class="comment">//获取结果对象列表</span></span><br><span class="line">List&lt;Demo&gt; demos = esDatas.getDatas();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取总记录数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">totalSize</span> <span class="operator">=</span> esDatas.getTotalSize();</span><br><span class="line">System.out.println(totalSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="配置es查询dsl"><a href="#配置es查询dsl" class="headerlink" title="配置es查询dsl"></a>配置es查询dsl</h3><p>在resources下创建配置文件estrace/ESTracesqlMapper.xml，配置一个query dsl脚本，名称为queryServiceByCondition，我们将在后面的ClientInterface 组件中通过queryServiceByCondition引用这个脚本，脚本内容定义如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queryServiceByCondition&quot;</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;sort&quot;: [  ##排序</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;startTime&quot;: &#123;</span><br><span class="line">                        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            #if($lastStartTime &gt; 0)//search_after分页查询</span><br><span class="line">            &quot;search_after&quot;: [#[lastStartTime]],</span><br><span class="line">            #end</span><br><span class="line">            &quot;size&quot;: 100, ##每次返回100条记录</span><br><span class="line">            &quot;query&quot;: &#123;</span><br><span class="line">                &quot;bool&quot;:&#123;</span><br><span class="line">                    &quot;filter&quot;: [</span><br><span class="line">                        &#123;&quot;term&quot;: &#123;  ##精确查找</span><br><span class="line">                            &quot;applicationName&quot;: #[application]</span><br><span class="line">                        &#125;&#125;</span><br><span class="line">                        #if($queryStatus.equals(&quot;success&quot;))</span><br><span class="line">                          ,</span><br><span class="line">                          &#123;&quot;term&quot;: &#123; ##精确查找</span><br><span class="line"></span><br><span class="line">                               &quot;err&quot;: 0</span><br><span class="line">                          &#125;&#125;</span><br><span class="line">                        #elseif($queryStatus.equals(&quot;error&quot;))</span><br><span class="line">                          ,</span><br><span class="line">                          &#123;&quot;term&quot;: &#123; ##精确查找</span><br><span class="line"></span><br><span class="line">                               &quot;err&quot;: 1</span><br><span class="line">                          &#125;&#125;</span><br><span class="line">                        #end</span><br><span class="line">                        ,</span><br><span class="line">                        &#123;&quot;range&quot;: &#123; ##指定时间范围</span><br><span class="line">                            &quot;startTime&quot;: &#123;</span><br><span class="line">                                &quot;gte&quot;: #[startTime],</span><br><span class="line">                                &quot;lt&quot;: #[endTime]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;&#125;</span><br><span class="line">                    ]</span><br><span class="line">                    </span><br><span class="line">                    #if($queryCondition &amp;&amp; !$queryCondition.equals(&quot;&quot;))</span><br><span class="line">                     ,</span><br><span class="line">                     &quot;must&quot; : &#123;</span><br><span class="line">                        &quot;multi_match&quot; : &#123; ##分词检索，指定坐在多个field执行检索</span><br><span class="line">                          &quot;query&quot; : #[queryCondition],</span><br><span class="line"></span><br><span class="line">                          &quot;fields&quot; : [ &quot;agentId&quot;, &quot;applicationName&quot; ,&quot;endPoint&quot;,&quot;params&quot;,&quot;remoteAddr&quot;,&quot;rpc&quot;,&quot;exceptionInfo&quot;]</span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                    #end</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;: &#123;</span><br><span class="line">                &quot;applicationsums&quot;: &#123;</span><br><span class="line">                      &quot;terms&quot;: &#123;</span><br><span class="line">                        &quot;field&quot;: &quot;applicationName.keyword&quot;,##按应用名称进行统计计数</span><br><span class="line">                        &quot;size&quot;:10000</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &quot;aggs&quot;:&#123;</span><br><span class="line">                            &quot;successsums&quot; : &#123;</span><br><span class="line">                                &quot;terms&quot; : &#123;</span><br><span class="line">                                    &quot;field&quot; : &quot;err&quot; ##按err标识统计每个应用的成功数和失败数，0标识成功，1标识失败</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &quot;elapsed_ranges&quot; : &#123;</span><br><span class="line">                                &quot;range&quot; : &#123;</span><br><span class="line">                                    &quot;field&quot; : &quot;elapsed&quot;, ##按响应时间分段统计</span><br><span class="line">                                    &quot;keyed&quot; : true,</span><br><span class="line">                                    &quot;ranges&quot; : [</span><br><span class="line">                                        &#123; &quot;key&quot; : &quot;1秒&quot;, &quot;to&quot; : 1000 &#125;,</span><br><span class="line">                                        &#123; &quot;key&quot; : &quot;3秒&quot;, &quot;from&quot; : 1000, &quot;to&quot; : 3000 &#125;,</span><br><span class="line">                                        &#123; &quot;key&quot; : &quot;5秒&quot;, &quot;from&quot; : 3000, &quot;to&quot; : 5000 &#125;,</span><br><span class="line">                                        &#123; &quot;key&quot; : &quot;5秒以上&quot;, &quot;from&quot; : 5000 &#125;</span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><br>查询的java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.frameworkset.elasticsearch.ElasticSearchHelper;</span><br><span class="line"><span class="keyword">import</span> org.frameworkset.elasticsearch.client.ClientInterface;</span><br><span class="line"><span class="comment">//加载配置文件，创建es客户端工具包</span></span><br><span class="line"><span class="type">ClientInterface</span> <span class="variable">clientUtil</span> <span class="operator">=</span> ElasticSearchHelper.getConfigRestClientUtil(<span class="string">&quot;estrace/ESTracesqlMapper.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建查询条件对象</span></span><br><span class="line"><span class="type">TraceExtraCriteria</span> <span class="variable">traceExtraCriteria</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraceExtraCriteria</span>();</span><br><span class="line">traceExtraCriteria.setApplication(<span class="string">&quot;testweb88&quot;</span>);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">traceExtraCriteria.setStartTime(dateFormat.parse(<span class="string">&quot;2017-09-02 00:00:00&quot;</span>).getTime());</span><br><span class="line">traceExtraCriteria.setEndTime(dateFormat.parse(<span class="string">&quot;2017-09-13 00:00:00&quot;</span>).getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索条件</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queryCondition</span> <span class="operator">=</span> (request.getParameter(<span class="string">&quot;queryCondition&quot;</span>));</span><br><span class="line"><span class="comment">// 设置检索条件</span></span><br><span class="line">traceExtraCriteria.setQueryCondition(queryCondition);</span><br><span class="line"><span class="comment">// 查询状态：all 全部 success 处理成功 fail 处理失败</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queryStatus</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;queryStatus&quot;</span>);</span><br><span class="line">traceExtraCriteria.setQueryStatus(queryStatus);</span><br><span class="line"><span class="comment">//设置分页数据起点，以时间为起点</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lastStartTimeStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;lastStartTime&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(lastStartTimeStr != <span class="literal">null</span> &amp;&amp; !lastStartTimeStr.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">lastStartTime</span> <span class="operator">=</span> Long.parseLong(lastStartTimeStr);</span><br><span class="line">    traceExtraCriteria.setLastStartTime(lastStartTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行查询操作，查询可以是简单的检索查询，也可以结合聚合查询</span></span><br><span class="line">ESDatas&lt;Traces&gt; data <span class="comment">//ESDatas为查询结果集对象，封装了返回的当前查询的List&lt;Traces&gt;结果集、符合条件的总记录数totalSize、以及聚合查询的结果</span></span><br><span class="line">            = clientUtil.searchList(<span class="string">&quot;trace-*/_search&quot;</span>,<span class="comment">//查询操作，查询indices trace-*中符合条件的数据</span></span><br><span class="line">                                <span class="string">&quot;queryServiceByCondition&quot;</span>,<span class="comment">//通过名称引用配置文件中的query dsl语句</span></span><br><span class="line">                                traceExtraCriteria,<span class="comment">//查询条件封装对象</span></span><br><span class="line">                                Traces.class);<span class="comment">//指定返回的po对象类型，po对象中的属性与indices表中的文档filed名称保持一致</span></span><br><span class="line">List&lt;Traces&gt; traceList = data.getDatas();<span class="comment">//获取查询到的记过集</span></span><br><span class="line"><span class="type">long</span> <span class="variable">totalSize</span> <span class="operator">=</span> data.getTotalSize();<span class="comment">//获取总记录数</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; applicationsums= data.getAggregationBuckets(<span class="string">&quot;applicationsums&quot;</span>);<span class="comment">//同时可以做聚合查询，获取聚合查询结果集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; applicationsums .size(); i++) &#123;</span><br><span class="line"> </span><br><span class="line">Map&lt;String, Object&gt; map = applicationsums.get(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取子聚合查询结果：成功数和失败数</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; appstatic = (List&lt;Map&lt;String, Object&gt;&gt;)ResultUtil.getAggBuckets(map, <span class="string">&quot;successsums&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取响应时间分段统计信息</span></span><br><span class="line">Map&lt;String, Map&lt;String, Object&gt;&gt; appPeriodstatic = (Map&lt;String, Map&lt;String, Object&gt;&gt;)ResultUtil.getAggBuckets(map, <span class="string">&quot;elapsed_ranges&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>封装条件也可以用Map替代</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line"><span class="comment">//设置applicationName1和applicationName2两个变量的值</span></span><br><span class="line">params.put(<span class="string">&quot;applicationName1&quot;</span>,<span class="string">&quot;blackca\&quot;tdemo2&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;applicationName2&quot;</span>,<span class="string">&quot;blackcat\&quot;demo3&quot;</span>);</span><br><span class="line">ESDatas&lt;Demo&gt; esDatas =  <span class="comment">//ESDatas包含当前检索的记录集合，最多1000条记录，由dsl中的size属性指定</span></span><br><span class="line">clientUtil.searchList(<span class="string">&quot;demo/_search&quot;</span>,<span class="comment">//demo为索引表，_search为检索操作action</span></span><br><span class="line"><span class="string">&quot;searchWithCustomEscape&quot;</span>,<span class="comment">//esmapper/demo.xml中定义的dsl语句</span></span><br><span class="line">params,<span class="comment">//变量参数</span></span><br><span class="line">Demo.class);<span class="comment">//返回的文档封装对象类型</span></span><br></pre></td></tr></table></figure></p><h3 id="文档批量创建或修改"><a href="#文档批量创建或修改" class="headerlink" title="文档批量创建或修改"></a>文档批量创建或修改</h3><p>按照日期分表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">一个完整的批量添加和修改索引文档的案例  </span><br><span class="line"><span class="comment">//分表的时间</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy.MM.dd&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> format.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">ClientInterface</span> <span class="variable">clientUtil</span> <span class="operator">=</span> ElasticSearchHelper.getRestClientUtil();</span><br><span class="line"><span class="comment">//数据1</span></span><br><span class="line">List&lt;Demo&gt; demos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">demo.setDemoId(<span class="number">2l</span>);</span><br><span class="line">demo.setAgentStarttime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">demo.setApplicationName(<span class="string">&quot;blackcatdemo2&quot;</span>);</span><br><span class="line">demo.setContentbody(<span class="string">&quot;this is content body2&quot;</span>);</span><br><span class="line">demos.add(demo);</span><br><span class="line"><span class="comment">//数据2</span></span><br><span class="line">demo = <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">demo.setDemoId(<span class="number">3l</span>);</span><br><span class="line">demo.setAgentStarttime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">demo.setApplicationName(<span class="string">&quot;blackcatdemo3&quot;</span>);</span><br><span class="line">demo.setContentbody(<span class="string">&quot;this is content body3&quot;</span>);</span><br><span class="line">demos.add(demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量创建文档</span></span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> clientUtil.addDateDocuments(<span class="string">&quot;demo&quot;</span>,<span class="comment">//索引表</span></span><br><span class="line"><span class="string">&quot;demo&quot;</span>,<span class="comment">//索引类型</span></span><br><span class="line">demos);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;addDateDocument-------------------------&quot;</span>);</span><br><span class="line">System.out.println(response);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量更新文档</span></span><br><span class="line">demo.setContentbody(<span class="string">&quot;updated&quot;</span>);</span><br><span class="line">response = clientUtil.updateDocuments(<span class="string">&quot;demo-&quot;</span>+date,<span class="string">&quot;demo&quot;</span>,demos);</span><br><span class="line">System.out.println(<span class="string">&quot;updateDateDocument-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(response);</span><br><span class="line">        <span class="comment">//获取索引文档，json格式</span></span><br><span class="line">response = clientUtil.getDocument(<span class="string">&quot;demo-&quot;</span>+date,<span class="comment">//索引表</span></span><br><span class="line"><span class="string">&quot;demo&quot;</span>,<span class="comment">//索引类型</span></span><br><span class="line"><span class="string">&quot;2&quot;</span>);<span class="comment">//文档id</span></span><br><span class="line">System.out.println(<span class="string">&quot;getDocument-------------------------&quot;</span>);</span><br><span class="line">System.out.println(response);</span><br><span class="line">        <span class="comment">//获取索引文档，返回Demo对象类型</span></span><br><span class="line">demo = clientUtil.getDocument(<span class="string">&quot;demo-&quot;</span>+date,<span class="comment">//索引表</span></span><br><span class="line"><span class="string">&quot;demo&quot;</span>,<span class="comment">//索引类型</span></span><br><span class="line"><span class="string">&quot;3&quot;</span>,<span class="comment">//文档id</span></span><br><span class="line">Demo.class);</span><br></pre></td></tr></table></figure><br>不按日期分表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个完整的批量添加和修改索引文档的案例  </span></span><br><span class="line"></span><br><span class="line"><span class="type">ClientInterface</span> <span class="variable">clientUtil</span> <span class="operator">=</span> ElasticSearchHelper.getRestClientUtil();</span><br><span class="line">List&lt;Demo&gt; demos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">demo.setDemoId(<span class="number">2l</span>);</span><br><span class="line">demo.setAgentStarttime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">demo.setApplicationName(<span class="string">&quot;blackcatdemo2&quot;</span>);</span><br><span class="line">demo.setContentbody(<span class="string">&quot;this is content body2&quot;</span>);</span><br><span class="line">demos.add(demo);</span><br><span class="line"></span><br><span class="line">demo = <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">demo.setDemoId(<span class="number">3l</span>);</span><br><span class="line">demo.setAgentStarttime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">demo.setApplicationName(<span class="string">&quot;blackcatdemo3&quot;</span>);</span><br><span class="line">demo.setContentbody(<span class="string">&quot;this is content body3&quot;</span>);</span><br><span class="line">demos.add(demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量创建文档</span></span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> clientUtil.addDocuments(<span class="string">&quot;demo&quot;</span>,<span class="comment">//索引表</span></span><br><span class="line"><span class="string">&quot;demo&quot;</span>,<span class="comment">//索引类型</span></span><br><span class="line">demos);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;addDocuments-------------------------&quot;</span>);</span><br><span class="line">System.out.println(response);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量更新文档</span></span><br><span class="line">demo.setContentbody(<span class="string">&quot;updated&quot;</span>);</span><br><span class="line">response = clientUtil.updateDocuments(<span class="string">&quot;demo&quot;</span>,<span class="string">&quot;demo&quot;</span>,demos);</span><br><span class="line">System.out.println(<span class="string">&quot;updateDateDocument-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(response);</span><br><span class="line">       <span class="comment">//获取索引文档，json格式</span></span><br><span class="line">response = clientUtil.getDocument(<span class="string">&quot;demo&quot;</span>,<span class="comment">//索引表</span></span><br><span class="line"><span class="string">&quot;demo&quot;</span>,<span class="comment">//索引类型</span></span><br><span class="line"><span class="string">&quot;2&quot;</span>);<span class="comment">//文档id</span></span><br><span class="line">System.out.println(<span class="string">&quot;getDocument-------------------------&quot;</span>);</span><br><span class="line">System.out.println(response);</span><br><span class="line">       <span class="comment">//获取索引文档，返回Demo对象类型</span></span><br><span class="line">demo = clientUtil.getDocument(<span class="string">&quot;demo&quot;</span>,<span class="comment">//索引表</span></span><br><span class="line"><span class="string">&quot;demo&quot;</span>,<span class="comment">//索引类型</span></span><br><span class="line"><span class="string">&quot;3&quot;</span>,<span class="comment">//文档id</span></span><br><span class="line">Demo.class);</span><br></pre></td></tr></table></figure><br>除了es能够自动生成文档_id属性，bboss提供了三种指定文档_id和parentid的方法：</p><ul><li>注解@ESId和@ESParentId</li><li>ClientInterface接口方法参数</li><li>ClientOptions（新增/修改）/UpdateOptions(修改控制)</li></ul><p>添加索引文档时，es会自动设置文档_id属性，如果需要人工指定_id值，只需要在对象属性上设置注解@ESId即可，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ESId</span> <span class="comment">//ip属性作为文档唯一标识，根据ip值对应的索引文档存在与否来决定添加或者修改操作</span></span><br><span class="line"><span class="keyword">private</span> String ip;</span><br></pre></td></tr></table></figure></p><h3 id="http-api"><a href="#http-api" class="headerlink" title="http api"></a>http api</h3><p>通过ClientInterface 接口提供的以下通用executeHttp api，我们可以非常方便地实现es中所有带请求报文的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClientInterface</span> <span class="variable">clientUtil</span> <span class="operator">=</span> ElasticSearchHelper.getRestClientUtil();</span><br><span class="line">     <span class="comment">//验证环境,获取es状态</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> clientUtil.executeHttp(<span class="string">&quot;/kibana_sample_data_logs/_search&quot;</span>, ClientInterface.HTTP_GET);</span><br><span class="line">     System.out.println(response);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTempate</span><span class="params">()</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">ClientInterface</span> <span class="variable">clientUtil</span> <span class="operator">=</span> ElasticSearchHelper.getConfigRestClientUtil(<span class="string">&quot;esmapper/estrace/ESTemplate.xml&quot;</span>);</span><br><span class="line"><span class="comment">//创建模板</span></span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> clientUtil.createTempate(<span class="string">&quot;demotemplate_1&quot;</span>,<span class="comment">//模板名称</span></span><br><span class="line"><span class="string">&quot;demoTemplate&quot;</span>);<span class="comment">//模板对应的脚本名称，在esmapper/estrace/ESTemplate.xml中配置</span></span><br><span class="line">System.out.println(<span class="string">&quot;createTempate-------------------------&quot;</span>);</span><br><span class="line">System.out.println(response);</span><br><span class="line"><span class="comment">//获取模板</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定模板</span></span><br><span class="line"><span class="comment"> * /_template/demoTemplate_1</span></span><br><span class="line"><span class="comment"> * /_template/demoTemplate*</span></span><br><span class="line"><span class="comment"> * 所有模板 /_template</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> clientUtil.executeHttp(<span class="string">&quot;/_template/demotemplate_1&quot;</span>,ClientUtil.HTTP_GET);</span><br><span class="line">System.out.println(<span class="string">&quot;HTTP_GET-------------------------&quot;</span>);</span><br><span class="line">System.out.println(template);</span><br><span class="line"><span class="comment">//删除模板</span></span><br><span class="line">template = clientUtil.executeHttp(<span class="string">&quot;/_template/demotemplate_1&quot;</span>,ClientUtil.HTTP_DELETE);</span><br><span class="line">System.out.println(<span class="string">&quot;HTTP_DELETE-------------------------&quot;</span>);</span><br><span class="line">System.out.println(template);</span><br><span class="line"></span><br><span class="line">template = clientUtil.executeHttp(<span class="string">&quot;/_template/demotemplate_1&quot;</span>,ClientUtil.HTTP_GET);</span><br><span class="line">System.out.println(<span class="string">&quot;HTTP_GET after delete-------------------------&quot;</span>);</span><br><span class="line">System.out.println(template);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="查询dsl动态脚本语法规范"><a href="#查询dsl动态脚本语法规范" class="headerlink" title="查询dsl动态脚本语法规范"></a>查询dsl动态脚本语法规范</h2><p>bboss elasticsearch采用xml文件管理elasticsearch的dsl脚本，在dsl脚本中可以使用变量、foreach循环、逻辑判断、注释；配置文件支持在线修改、自动热加载，开发和调试非常方便。</p><p>脚本中变量定义语法有两种:#[xxx],$xxx,尽可能地在脚本中使用#[xxx]方式的变量，在#[]类型变量中还可以指定属性，后面举例说明。对于#[xxx]类型变量值中包含的可能破坏dsl json语法结构的特殊字符（例如回车换行符等），框架会自动进行转义处理；$xxx类型变量直接输出原始值（特殊字符不做转移处理），$xxx类型变量可以用于if/else和foreach循环控制变量，而#[xxx]不可以。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">判断List集合datas不为空并且datas的size大于0</span><br><span class="line"></span><br><span class="line">#if（$datas &amp;&amp; $datas.size()&gt; 0)</span><br><span class="line"></span><br><span class="line">#foreach($bb in $datas)</span><br><span class="line"></span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#end </span><br></pre></td></tr></table></figure><ul><li>foreach循环语法：</li></ul><blockquote><p>#foreach-#end<br>foreach循环内置循环变量：$velocaitycount，不需要从外部传入</p></blockquote><ul><li><p>逻辑判断语法：</p><blockquote><p>#if-#else-#end,#if-#elseif-#else-#end<br>变量值逻辑判断<br>#if($xxxx)<br>#end<br>变量值不为null判断（类似java语法 if(xxxx != null)）<br>#if(!$xxxx)<br>#end<br>变量值为null判断（类似java语法 if(xxxx == null)）<br>#if($xxxx &amp;&amp; !$xxxx.equals(“”))<br>#end<br>变量值不为null判断且不等于”“判断（类似java语法 if(xxxx != null &amp;&amp; !xxx.equals(””))）<br>#if($xxxx &gt; 0)<br>#end<br>变量值大于某个值判断,其他类似（类似java语法 if(xxxx &gt; 0)）<br>#if($datas &amp;&amp; $datas.size() &gt; 0)<br>#end<br>判断List集合不为null并且size大于0,逻辑判断还可以包含各种组合 &amp;&amp; ||操作。</p></blockquote></li><li><p>在dsl中定义和修改$模式变量：</p><ul><li>定义变量<blockquote><p>#set($needComma = true)</p></blockquote></li><li>修改$变量值<blockquote><p>#set($needComma = false)</p></blockquote></li></ul></li><li><p>在dsl中使用注释：<br>dsl注释是用多个#号来标识的，大段注释用#<em>和</em>#包起来<br>单行注释：##注释内容</p></li><li><p>变量使用：</p><blockquote><p>#[application]<br>变量格式#[aaa]所有格式：</p></blockquote></li></ul><blockquote><p>#[aaa]<br>简单的变量属性引用</p><p>#[aaa-&gt;bb]<br>如果aaa是一个bean对象，这个变量格式表示了对aaa对象的bb属性的引用，如果aaa是一个map对象，这个变量格式表示了对aaa对象的key为bb的元素值引用</p><p>#[aaa[key]]<br>引用map对象aaa中key所对应的value数据,引用map元素的等价方法#[aaa-&gt;key]</p></blockquote><h2 id="配置springboot"><a href="#配置springboot" class="headerlink" title="配置springboot"></a>配置springboot</h2><p>application.properties如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch.rest.hostNames=localhost:9200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#动态索引表名称日期格式配置</span><br><span class="line">elasticsearch.dateFormat=yyyy.MM.dd</span><br><span class="line"></span><br><span class="line">elasticsearch.timeZone=Asia/Shanghai</span><br><span class="line">elasticsearch.ttl=2d</span><br><span class="line"></span><br><span class="line">#在控制台输出脚本调试开关showTemplate,false关闭，true打开，同时log4j至少是info级别</span><br><span class="line">elasticsearch.showTemplate=false</span><br><span class="line"></span><br><span class="line">#客户端动态发现es集群节点控制开关</span><br><span class="line">elasticsearch.discoverHost=false</span><br><span class="line"></span><br><span class="line">#http链接池配置</span><br><span class="line">http.timeoutConnection = 400000</span><br><span class="line">http.timeoutSocket = 400000</span><br><span class="line">http.connectionRequestTimeout=400000</span><br><span class="line">http.retryTime = 1</span><br><span class="line">http.maxLineLength = -1</span><br><span class="line">http.maxHeaderCount = 200</span><br><span class="line">http.maxTotal = 400</span><br><span class="line">http.defaultMaxPerRoute = 200</span><br><span class="line"></span><br><span class="line"># dsl配置文件热加载扫描时间间隔，毫秒为单位，默认5秒扫描一次，&lt;= 0时关闭扫描机制</span><br><span class="line">dslfile.refreshInterval = -1</span><br></pre></td></tr></table></figure><br>依赖如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- bboss客户端开始 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bbossgroups.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bboss-elasticsearch-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bbossgroups.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bboss-elasticsearch-rest-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.plugin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xerial<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sqlite-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.23.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- bboss客户端结束 --&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>引用文章：</strong><br><a href="https://blog.csdn.net/No_Game_No_Life_/article/details/90407228">https://blog.csdn.net/No_Game_No_Life_/article/details/90407228</a></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java项目———里吉外卖(下半)</title>
      <link href="/posts/d32f9f91.html"/>
      <url>/posts/d32f9f91.html</url>
      
        <content type="html"><![CDATA[<h1 id="里吉外卖开发日记-上"><a href="#里吉外卖开发日记-上" class="headerlink" title="里吉外卖开发日记-上"></a>里吉外卖开发日记-上</h1><hr><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><img src="https://picbed.kirony.xyz/img/r11.png" alt="code"><br><img src="https://picbed.kirony.xyz/img/r12.png" alt="code"></p><h3 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>MysSQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的二进制日志功能。就是一台或多台AysQL数据库(slave，即从库）从另一台MysQL数据库(master，即主库）进行日志的复制然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是MysQL数据库自带功能，无需借助第三方工具。</p><p>MysQL复制过程分成三步:</p><ul><li>master将改变记录到二进制日志（ binary log)</li><li>slave将master的binary log拷贝到它的中继日志（relay log）</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中<br><img src="https://picbed.kirony.xyz/img/r13.png" alt="code"><h4 id="配置-前置条件"><a href="#配置-前置条件" class="headerlink" title="配置-前置条件"></a>配置-前置条件</h4>因为只有一个服务器能用，所以采用docker容器方式部署多个Mysql进行主从复制，服务器安装docker方式不多赘述，在安装完以后使用<strong>docker pull mysql</strong>拉取Mysql镜像</li></ul><p>因为docker容器之间完全隔离，所以可以根据不同的docker容器映射宿主机的不同端口去完成多个mysql的主从复制，我这里使用的是拉取两个mysql镜像分别作为master和slave数据库进行主从复制的配置。<br>master主容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3339:3306 --name master -v /root/master/conf:/etc/mysql/conf.d - /root/master/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure><br> slave从容器<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3340:3306 --name slave -v /root/master/conf:/etc/mysql/conf.d - /root/master/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure></p><h4 id="配置-主库Master"><a href="#配置-主库Master" class="headerlink" title="配置-主库Master"></a>配置-主库Master</h4><p>第一步:修改Mysql数据库的配置文件/etc/my.cnf<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin #[必须]启用二进制日志</span><br><span class="line">server-id=100 #[必须]服务器唯一ID</span><br></pre></td></tr></table></figure><br>第二步:重启Mysql服务<br>systemctl restart mysqld</p><p>第三步:登录Mysql数据库，执行下面SQL</p><p>GRANT REPLICATION SLAVE ON <em>.</em> to ‘xiaoming’@’%’ identified by ‘Root@123456’;</p><p>注:上面SQL的作用是创建一个用户xiaoming，密码为Root@123456，并且给xiaoming用户授予REPLICATION SLAVE权限。常用于建立复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。</p><p>第四步:登录Mysql数据库，执行下面SQL，记录下结果中File和Position的值</p><p>show master status;<br><img src="https://picbed.kirony.xyz/img/r14.png" alt="code"><br>注:上面SQL的作用是查看Master的状态，执行完此SQL后不要再执行任何操作</p><h4 id="配置-从库Slave"><a href="#配置-从库Slave" class="headerlink" title="配置-从库Slave"></a>配置-从库Slave</h4><p>第一步:修改Mysq1数据库的配置文件/etc/my.cnf<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=101 #[必须]服务器唯一ID</span><br></pre></td></tr></table></figure><br>第二步:重启Mysql服务<br>systemctl restart mysqld</p><p>第三步:登录Mysq1数据库，执行下面SQL<br>master_host可以使用docker inspect master去查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span></span><br><span class="line">master_host<span class="operator">=</span><span class="string">&#x27;这里使用的是容器的host&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;xiaoming&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000003&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">441</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure><br>第四步:登录Mysql数据库，执行下面SQL，查看从数据库的状态show slave status;<br><img src="https://picbed.kirony.xyz/img/r15.png" alt="code">\</p><h3 id="读写分离案例"><a href="#读写分离案例" class="headerlink" title="读写分离案例"></a>读写分离案例</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为主库和从库，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善<br><img src="https://picbed.kirony.xyz/img/r16.png" alt="code"></p><h4 id="Sharding-JDBC介绍"><a href="#Sharding-JDBC介绍" class="headerlink" title="Sharding-JDBC介绍"></a>Sharding-JDBC介绍</h4><p>Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库,以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><p>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。</p><ul><li>适用于任何基于JDBC的ORM框架，如: JPA, Hibernate,Mybatis, Spring JDBC Template或直接使用JDBC。</li><li>支持任何第三方的数据库连接池，如:DBCP，C3PO,BoneCP, Druid, HikariCP等。</li><li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle,SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h4><p>使用Sharding-JDBC实现读写分离步骤:</p><p>1、导入maven坐标</p><p>2、在配置文件中配置读写分离规则<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span></span><br><span class="line">        <span class="string">master,slave</span></span><br><span class="line">      <span class="comment"># 主数据源</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器外网ip:3306/riggie?characterEncoding=utf-8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="comment"># 从数据源</span></span><br><span class="line">      <span class="attr">slave:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器外网ip:3306/riggie?characterEncoding=utf-8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="comment"># 读写分离配置</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span> <span class="comment">#轮询</span></span><br><span class="line">      <span class="comment"># 最终的数据源名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">      <span class="comment"># 主库数据源名称</span></span><br><span class="line">      <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 从库数据源名称列表，多个逗号分隔</span></span><br><span class="line">      <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br></pre></td></tr></table></figure><br>3、在配置文件中配置允许bean定义覆盖配置项<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">main:</span></span><br><span class="line">        <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h3 id="项目实现读写分离"><a href="#项目实现读写分离" class="headerlink" title="项目实现读写分离"></a>项目实现读写分离</h3><h4 id="环境准备-主从复制"><a href="#环境准备-主从复制" class="headerlink" title="环境准备(主从复制)"></a>环境准备(主从复制)</h4><p>直接使用我们前面在虚拟机中搭建的主从复制的数据库环境即可。</p><p>在主库中创建瑞吉外卖项目的业务数据库riggie并导入相关表结构和数据。</p><h4 id="代码构造"><a href="#代码构造" class="headerlink" title="代码构造"></a>代码构造</h4><p>在项目中加入Sharding-JDBC实现读写分离步骤:</p><p>1、导入maven坐标</p><p>2、在配置文件中配置读写分离规则</p><p>3、在配置文件中配置允许bean定义覆盖配置项</p><hr><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h3><p>Nginx是一款轻量级的web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有:百度、京东、新浪、网易、腾讯、淘宝等。</p><p>Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler .ru站点（俄文: Paw6nep)开发的，第一个公开版本0.1.e发布于2004年10月4日。</p><p>官网: <a href="https://nginx.org/">https://nginx.org/</a></p><h3 id="Nginx下载与安装"><a href="#Nginx下载与安装" class="headerlink" title="Nginx下载与安装"></a>Nginx下载与安装</h3><p>可以到Nginx官方网站下载Nginx的安装包，地址为: <a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p><p>安装过程:<br>1、安装依赖包yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</p><p>2、下载Nginx安装包wget <a href="https://nginx.org/download/nginx-1.16.1.tar.gz(需要先yum">https://nginx.org/download/nginx-1.16.1.tar.gz(需要先yum</a> install wget)</p><p>3、解压tar -zxvf nginx-1.16.1.tar.gz</p><p>4、cd nginx-1.16.1</p><p>5、./ configure —prefix=/usr/local/nginx</p><p>6、make &amp;&amp; make install</p><h3 id="ginx目录结构"><a href="#ginx目录结构" class="headerlink" title="ginx目录结构"></a>ginx目录结构</h3><p>安装完Nginx后，我们先来熟悉一下Nginx的目录结构，如下图:<br><img src="https://picbed.kirony.xyz/img/r17.png" alt="code"><br>重点目录/文件:</p><ul><li>conf/nginx.conf nginx配置文件</li><li>html<br>  存放静态文件(html、css、Js等)</li><li>logs<br>  日志目录，存放日志文件</li><li>sbin/nginx<br>  二进制文件，用于启动、停止Nginx服务<h3 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h3><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4>在sbin目录下输入./nginx -v</li></ul><h4 id="检查配置文件正确性"><a href="#检查配置文件正确性" class="headerlink" title="检查配置文件正确性"></a>检查配置文件正确性</h4><p>在启动Nginx服务之前，可以先检查一下conf/nginx.conf文件配置的是否有错误，命令如下:</p><p>./nginx -t<br><img src="https://picbed.kirony.xyz/img/r18.png" alt="code"></p><h4 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h4><p>在sbin目录下。</p><p>启动Nginx服务使用如下命令:./nginx</p><p>停止Nginx服务使用如下命令:./nginx -s stop</p><p>启动完成后可以查看Nginx进程:ps -ef | grep nginx</p><p>修改运行的进程数目：<br>vim usr/local/nginx/conf/nginx.conf<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  2;</span><br></pre></td></tr></table></figure></p><h4 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h4><p>可以通过修改profile文件配置环境变量，在/目录下可以直接使用nginx命令</p><p>vim etc/profile<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/local/nginx/sbin:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><br>使配置文件生效：source /etc/profile</p><p>重启Nginx：nginx -s reload</p><p>停止Nginx：nginx -s stop</p><p>启动Nginx：nginx</p><h3 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h3><p><strong>整体结构介绍</strong></p><p>Nginx配置文件(conf/nginx.conf)整体分为三部分:</p><ul><li>全局块<br>  和Nginx运行相关的全局配置</li><li>events块<br>  和网络连接相关的配置</li><li>http块<br>  代理、缓存、日志记录、虚拟主机配置<ul><li>http全局块</li><li>Server块<ul><li>Server全局块</li><li>location块<br>注意:http块中可以配置多个Server块，每个Server块中可以配置多个location块。<br><img src="https://picbed.kirony.xyz/img/r19.png" alt="code"></li></ul></li></ul></li></ul><h3 id="Nginx具体应用"><a href="#Nginx具体应用" class="headerlink" title="Nginx具体应用"></a>Nginx具体应用</h3><h4 id="部署静态资源"><a href="#部署静态资源" class="headerlink" title="部署静态资源"></a>部署静态资源</h4><p>Nginx可以作为静态web服务器来部署静态资源。静态资源指在服务端真实存在并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</p><p>相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中。</p><p>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;                #监听端口</span><br><span class="line">  server_name localhost;    #服务器名称</span><br><span class="line">  location/&#123;                #匹配客户端请求url</span><br><span class="line">    root html;              #指定静态资源根目录</span><br><span class="line">    index index.html;       #指定默认首页</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul><li><p>正向代理</p><p>  是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p>  正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。</p><p>  正向代理一般是在客户端设置代理服务器，通过代理服务器转发请求，最终访问到目标服务器。<br><img src="https://picbed.kirony.xyz/img/r20.png" alt="code"></p></li><li><p>反向代理</p><p>  反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。</p><p>  用户不需要知道目标服务器的地址，也无须在用户端作任何设定。<br><img src="https://picbed.kirony.xyz/img/r21.png" alt="code"></p></li><li><p>配置反向代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       82;</span><br><span class="line">  server_name  localhost;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">          proxy_pass http://后端服务器ip:8080; #反向代理配置</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</p></li><li><p>应用集群:将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据</p></li><li>负载均衡器:将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理<br><img src="https://picbed.kirony.xyz/img/r22.png" alt="code"><h4 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡:"></a>配置负载均衡:</h4>修改ngnix.conf<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream targetserver&#123;    #upstream指令可以定义一组服务器</span><br><span class="line">  server 二号服务器ip:8080;</span><br><span class="line">  server 三号服务器ip:8080;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen  8080;</span><br><span class="line">  server_name     localhost; #一号服务器</span><br><span class="line">  location / &#123;</span><br><span class="line">          proxy_pass http://targetserver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>负载均衡策略</strong><br><img src="https://picbed.kirony.xyz/img/r23.png" alt="code"></li></ul><h4 id="docker容器实现Nginx前端部署"><a href="#docker容器实现Nginx前端部署" class="headerlink" title="docker容器实现Nginx前端部署"></a><span id='docker_nginx'>docker容器实现Nginx前端部署</span></h4><p>还是因为只有一台服务器的缘故，继续使用轻松好用的docker容器，Nginx的镜像一样使用pull命令拉取，拉取以后因为启动时缺少Nginx的配置文件，所以需要先copy出来一份镜像Nginx的default.conf<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name 服务器ip;</span><br><span class="line"></span><br><span class="line">  location /&#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ^~ /api/&#123;</span><br><span class="line">          rewrite ^/api/(.*)$ /$1 break;</span><br><span class="line">          proxy_pass http://后端服务器ip:3341;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error_page 500 502 503 504 /50x.html;</span><br><span class="line">  location = /50x.html&#123;</span><br><span class="line">      root html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里加入配置以后运行镜像同时映射配置文件<br>ps.大部分docker容器最好使用-v将容器内文件路径与宿主机文件路径映射，避免容器运行以后进入容器内修改配置文件的繁琐</p><p>启动Nginx镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 -v /home/etc/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /home/nginx/dist:/usr/share/nginx/html --name myNginx -d nginx</span><br><span class="line"><span class="comment">#-v 后面的路径映射是因为先cp了一份nginx配置文件，其实直接映射一份.conf就行</span></span><br><span class="line"><span class="comment">#还有注意容器内nginx的html静态文件夹是/usr下，注意手快</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="前后端分离开发"><a href="#前后端分离开发" class="headerlink" title="前后端分离开发"></a>前后端分离开发</h2><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>开发人员同时负责前端和后端代码开发，分工不明确</li><li>开发效率低</li><li>前后端代码混合在一个工程中，不便于管理</li><li>对开发人员要求高，人员招聘困难</li></ul><h3 id="前后端分离开发-1"><a href="#前后端分离开发-1" class="headerlink" title="前后端分离开发"></a>前后端分离开发</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>前后端分离开发，就是在项目开发过程中，对于前端代码的开发由专门的前端开发人员负责，后端代码则由后端开发人员负责，这样可以做到分工明确、各司其职，提高开发效率，前后端代码并行开发，可以加快项目开发进度。目前，前后端分离开发方式已经被越来越多的公司所采用，成为当前项目开发的主流开发方式。</p><p>前后端分离开发后，从工程结构上也会发生变化，即前后端代码不再混合在同一个maven工程中，而是分为前端工程和后端工程。<br><img src="https://picbed.kirony.xyz/img/r24.png" alt="code"></p><h4 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h4><p>前后端分离开发后，面临一个问题，就是前端开发人员和后端开发人员如何进行配合来共同开发一个项目?可以按照如下流程进行:<br><img src="https://picbed.kirony.xyz/img/r25.png" alt="code"><br><img src="https://picbed.kirony.xyz/img/r26.png" alt="code"><br>接口(API接口) 就是一个http的请求地址，主要就是去定义:请求路径、请求方式、请求参数、响应数据等内容</p><h4 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h4><p>开发工具</p><ul><li>Visual Studio Code</li><li><p>hbuilder<br>技术框架</p></li><li><p>nodejs</p></li><li>VUE</li><li>ElementUI</li><li>mock</li><li>webpack</li></ul><h3 id="Yapi"><a href="#Yapi" class="headerlink" title="Yapi"></a>Yapi</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>YApi是高效、易用、功能强大的api管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。</p><p>YApi让接口开发更简单高效，让接口的管理更具可读性、可维护性，让团队协作更合理。</p><p>源码地址: <a href="https://github.com/YMFE/yapi">https://github.com/YMFE/yapi</a></p><p>要使用YApi，需要自己进行部署。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用YApi可以执行下面操作</p><ul><li>添加项目</li><li>添加分类</li><li>添加接口</li><li>编辑接口</li><li>查看接口<h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4>使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，再通过Swagger衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，以及在线接口调试页面等等。</li></ul><p>官网:<a href="https://swagger.io/">https://swagger.io/</a></p><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>操作步骤:</p><p>1、导入knife4j的maven坐标<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>2、导入knife4j相关配置类</p><p>WebMvcConfig<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//文档类型</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">              .apiInfo(apiInfo())</span><br><span class="line">              .select()</span><br><span class="line">              .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.ka.reggie.controller&quot;</span>))</span><br><span class="line">              .paths(PathSelectors.any())</span><br><span class="line">              .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">              .title(<span class="string">&quot;瑞吉外卖&quot;</span>)</span><br><span class="line">              .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">              .description(<span class="string">&quot;瑞吉外卖接口文档&quot;</span>)</span><br><span class="line">              .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3、设置静态资源，否则接口文档页面无法访问(addResourceHandlers方法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.addResourceHandler(<span class="string">&quot;doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br></pre></td></tr></table></figure><br>4、在LoginCheckFilter中设置不需要处理的请求路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] urls = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">        <span class="string">&quot;/employee/login&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/employee/logout&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/backend/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/front/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/common/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/user/sendMsg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;/doc.html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/swagger-resources&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/v2/api-docs&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p>|注解|    说明|<br>|@Api|用在请求的类上，例如Controller，表示对类的说明|<br>|@ApiModel|    用在类上，通常是实体类，表示一个返回响应数据的信息|<br>|@ApiModelProperty|    用在属性上，描述响应类的属性|<br>|@ApiOperation|    用在请求的方法上，说明方法的用途、作用|<br>|@ApilmplicitParams|    用在请求的方法上，表示一组参数说明|<br>|ApilmplicitParam|    用在@ApilmplicitParams注解中，指定一个请求参数的各个方面|</p><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><h4 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h4><p><img src="https://picbed.kirony.xyz/img/r27.png" alt="code"></p><h4 id="部署环境说明"><a href="#部署环境说明" class="headerlink" title="部署环境说明"></a>部署环境说明</h4><p>服务器:</p><p>192.168.138.100（服务器A)</p><p>Nginx:部署前端项目、配置反向代理</p><p>Mysql:主从复制结构中的主库</p><p>Redis:缓存中间件</p><p>192.168.138.101（服务器B)</p><p>jdk:运行Java项目</p><p>git:版本控制工具</p><p>maven:项目构建工具</p><p>jar: Spring Boot项目打成jar包基于内置Tomcat运行</p><p>Mysql:主从复制结构中的从库</p><h4 id="部署前端项目"><a href="#部署前端项目" class="headerlink" title="部署前端项目"></a>部署前端项目</h4><p>前端部署已经在上面的Nginx部署中讲到了：<a href="#docker_nginx">docker容器nginx部署前端项目</a></p><h4 id="部署后端项目"><a href="#部署后端项目" class="headerlink" title="部署后端项目"></a>部署后端项目</h4><p>后端部署很花了我一点时间，因为不太确定docker内部容器之间的连接是否可以通过ip直连，后来经过俺的多次测试以后成功，得到以下结论：</p><ul><li>1.首先排除服务器ip对外开放端口连接，因为后端项目也需要从本地部署到linux服务器中，所以不能用原本的外网ip开放端口连接数据库or缓存，但是因为前端是由Nginx代理部署的，所以Nginx中的后端代理ip依然可以是服务器外网ip的对外开放端口，无需容器内连接。</li><li>2.测试了容器名连接，这种需要在容器运行时使用link命令将容器之间连接起来，或者更改容器的host表之类的操作进行连接</li><li>3.最有效的还是通过docker inspect 容器名 去查询容器的ipadress，因为docker容器之间完全隔离，所以在每个容器启动时都会分配一个新的ip地址<br><img src="https://picbed.kirony.xyz/img/r28.png" alt="code"><br>得到ip地址以后替换对应的mysql的配置以及redis的配置即可</li></ul><p>application.yml配置完成以后将后端项目进行打包：</p><ul><li>最简单的方式是直接maven的package方式打包</li><li>当然还可以使用build Artifact 实现JAR包方式，但经常出现漏掉一些第三方jar包的情况</li></ul><p>ps.打完jar包以后在本地先运行一次，因为pom.xml中的依赖版本问题有可能会导致打包时出现jar包没有进去的问题，导致jar包运行失败，如果出现了无法运行，尝试改变一下依赖中的第三方jar包版本</p><p>打包成功以后上传到linux服务器中，使用docker将jar包制作成自定义镜像<br>新建一个Dockerfile文件，制作镜像专用<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line"></span><br><span class="line">ADD takeout_api.jar app.jar</span><br><span class="line"></span><br><span class="line">EXPOSE 3341</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><br>将jar放到同一层路径下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t app .</span><br><span class="line"><span class="comment"># -f可以指定dockerfile的路径 app是为镜像取名 最后.是所在目录，因为是同级</span></span><br></pre></td></tr></table></figure><br>docker images查看镜像，查看镜像制作成功以后创建容器运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3341:8080 --name takeout app</span><br><span class="line"><span class="comment">#-d是容器在后台启动 -t是启动容器</span></span><br></pre></td></tr></table></figure><br>docker ps查看正在运行的容器</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java项目———里吉外卖(上半)</title>
      <link href="/posts/ee4fb621.html"/>
      <url>/posts/ee4fb621.html</url>
      
        <content type="html"><![CDATA[<h1 id="里吉外卖开发日记-上"><a href="#里吉外卖开发日记-上" class="headerlink" title="里吉外卖开发日记-上"></a>里吉外卖开发日记-上</h1><hr><h2 id="开发整体介绍"><a href="#开发整体介绍" class="headerlink" title="开发整体介绍"></a>开发整体介绍</h2><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p><img src="https://picbed.kirony.xyz/img/r1.png" alt="code"></p><h3 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h3><p><img src="https://picbed.kirony.xyz/img/r2.png" alt="code"></p><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p><img src="https://picbed.kirony.xyz/img/r3.png" alt="code"></p><hr><h2 id="里吉外卖项目介绍"><a href="#里吉外卖项目介绍" class="headerlink" title="里吉外卖项目介绍"></a>里吉外卖项目介绍</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p><img src="https://picbed.kirony.xyz/img/r4.png" alt="code"></p><h3 id="产品原型展示"><a href="#产品原型展示" class="headerlink" title="产品原型展示"></a>产品原型展示</h3><p><img src="https://picbed.kirony.xyz/img/r5.png" alt="code"></p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p><img src="https://picbed.kirony.xyz/img/r6.png" alt="code"></p><h3 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h3><p><img src="https://picbed.kirony.xyz/img/r7.png" alt="code"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><img src="https://picbed.kirony.xyz/img/r8.png" alt="code"></p><hr><h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p><img src="https://picbed.kirony.xyz/img/r9.png" alt="code"><br><strong>用户数量多，系统访问量大频繁访问数据库，系统性能下降，用户体验差</strong></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h4><p>在项目的pom.xm1文件中导入spring data redis的maven坐标:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>在项目的application.yml中加入redis相关配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="string">host:172.17.2.94</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root@123456</span></span><br><span class="line">        <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>在项目中加入配置类RedisConfig:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//默认的Key序列化器为: JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setConnectionFactory( connectionFactory) ;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用StringRedisTemplate就不用配置类</p><h3 id="缓存短信验证码"><a href="#缓存短信验证码" class="headerlink" title="缓存短信验证码"></a>缓存短信验证码</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>前面我们已经实现了移动端手机验证码登录，随机生成的验证码我们是保存在HttpSession中的。现在需要改造为将验证码缓存在Redis中，具体的实现思路如下:</p><p>1、在服务端UserController中注入RedisTemplate对象，用于操作Redis<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure><br>2、在服务端UserController的sendMsg方法中，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(phone,code,<span class="number">5</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><br>3、在服务端UserController的login方法中，从Redis中获取缓存的验证码，如果登录成功则删除Redis中的验证码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从redis中获取保存的验证码</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">codeInSession</span> <span class="operator">=</span>redisTemplate.opsForValue().get(phone);</span><br><span class="line"><span class="comment">//如果用户登录成功则删除Redis中缓存的验证码</span></span><br><span class="line">redisTemplate.delete(phone);</span><br></pre></td></tr></table></figure></p><h3 id="缓存菜品数据"><a href="#缓存菜品数据" class="headerlink" title="缓存菜品数据"></a>缓存菜品数据</h3><h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><p>前面我们已经实现了移动端菜品查看功能，对应的服务端方法为DishController的list方法，此方法会根据前端提交的查询条件进行数据库查询操作。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。现在需要对此方法进行缓存优化，提高系统的性能。</p><p>具体的实现思路如下:</p><p>1、改造DishController的list方法，先从Redis中获取菜品数据，如果有则直接返回，无需查询数据库;如果没有则查询数据库，并将查询到的菜品数据放入Redis。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DishDto&gt; dishDtoList=<span class="literal">null</span>;</span><br><span class="line"><span class="comment">//动态构造Key</span></span><br><span class="line">String key=<span class="string">&quot;dish_&quot;</span>+dish.getCategoryId()+<span class="string">&quot;_&quot;</span>+dish.getStatus();</span><br><span class="line"><span class="comment">//先从redis中获取缓存数据</span></span><br><span class="line">dishDtoList= (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="keyword">if</span>(dishDtoList!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//如果存在，则直接返回，无需查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> R.success(dishDtoList);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果不存在，则查询数据库，并且将查询到的菜品数据添加到缓存中</span></span><br><span class="line">redisTemplate.opsForValue().set(key,dishDtoList,<span class="number">60</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><br>2、改造DishController的save和update方法，加入清理缓存的逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理所有菜品缓存数据</span></span><br><span class="line"><span class="comment">//Set keys = redisTemplate.keys(&quot;dish_*&quot;);</span></span><br><span class="line"><span class="comment">//redisTemplate.delete(keys);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清理某个分类下面的菜品缓存数据</span></span><br><span class="line">String key=<span class="string">&quot;dish_&quot;</span>+dishDto.getCategoryId()+<span class="string">&quot;_&quot;</span>+dishDto.getStatus();</span><br><span class="line">redisTemplate.delete(key);</span><br></pre></td></tr></table></figure><br><strong>注意：</strong>在使用缓存过程中，要注意保证数据库中的数据和缓存中的数据一致，如果数据库中的数据发生变化，需要及时清理缓存数据。</p><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><h4 id="Spring-Cache介绍"><a href="#Spring-Cache介绍" class="headerlink" title="Spring Cache介绍"></a>Spring Cache介绍</h4><p>Spring cache是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p><p>Spring Cache提供了一层抽象，底层可以切换不同的cache实现。具体就是通过CacheManager接口来统一不同的缓存技术。</p><p>CacheManager是Spring提供的各种缓存技术抽象接口。</p><p>针对不同的缓存技术需要实现不同的CacheManager:<br><img src="https://picbed.kirony.xyz/img/r10.png" alt="code"></p><h4 id="Spring-Cache常用注解"><a href="#Spring-Cache常用注解" class="headerlink" title="Spring Cache常用注解"></a>Spring Cache常用注解</h4><p><img src="https://picbed.kirony.xyz/img/r11.png" alt="code"><br>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。</p><p>例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。</p><h4 id="Spring-Cache使用方式"><a href="#Spring-Cache使用方式" class="headerlink" title="Spring Cache使用方式"></a>Spring Cache使用方式</h4><p>在Spring Boot项目中使用Spring Cache的操作步骤(使用redis缓存技术);</p><p>1、导入maven坐标</p><ul><li>spring-boot-starter-data-redis、spring-boot-starter-cache</li></ul><p>2、配置application.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">redis:</span></span><br><span class="line">            <span class="attr">time-to-live:</span> <span class="number">1800000</span><span class="comment">#设置缓存有效期</span></span><br></pre></td></tr></table></figure><br>3、在启动类上加入@EnableCaching注解，开启缓存注解功能</p><p>4、在Controller的方法上加入@Cacheable、@CacheEvict等注解，进行缓存操作</p><h3 id="缓存套餐数据"><a href="#缓存套餐数据" class="headerlink" title="缓存套餐数据"></a>缓存套餐数据</h3><h4 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h4><p>前面我们已经实现了移动端套餐查看功能，对应的服务端方法为SetmealController的list方法，此方法会根据前端提交的查询条件进行数据库查询操作。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。现在需要对此方法进行缓存优化，提高系统的性能。</p><p>具体的实现思路如下:</p><p>1、导入Spring Cache和Redis相关maven坐标</p><p>2、在application.yml中配置缓存数据的过期时间</p><p>3、在启动类上加入@EnableCaching注解，开启缓存注解功能</p><p>4、在SetmealController的list方法上加入@Cacheable注解</p><p>5、在SetmealController的save和delete方法上加入CacheEvict注解</p><h4 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h4><p>在pom.xml文件中导入maven坐标:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在application.yml中配置缓存数据过期时间:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">time-to-live:</span> <span class="number">1800000</span> <span class="comment">#设置缓存数据过期时间</span></span><br></pre></td></tr></table></figure><br>在启动类@EnableCaching注解</p><p>在list方法上添加注解，实现在redis里添加缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value = &quot;setmealCache&quot;,key = &quot;#setmeal.categoryId+&#x27;_&#x27;+#setmeal.status&quot;)</span></span><br></pre></td></tr></table></figure><br>在update，add，delete方法上添加注解，清除缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;setmealCache&quot;,allEntries = true)</span></span><br></pre></td></tr></table></figure><br><strong>注意：</strong>要让R实现Serializable接口（序列化），注解才能生效</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高频面试八股文-下半</title>
      <link href="/posts/5cf3543a.html"/>
      <url>/posts/5cf3543a.html</url>
      
        <content type="html"><![CDATA[<h1 id="B树和B-树的区别，为什么Mysql使用B-树"><a href="#B树和B-树的区别，为什么Mysql使用B-树" class="headerlink" title="B树和B+树的区别，为什么Mysql使用B+树"></a>B树和B+树的区别，为什么Mysql使用B+树</h1><p><strong>B树的特点:</strong></p><ol><li>节点排序</li><li>一个节点了可以存多个元素，多个元素也升序排序了<br><strong>B+树的特点:</strong></li><li>拥有B树的特点</li><li>2.叶子节点之间有指针</li><li>非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序<br>Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高。在MysqI中一个Innodb页就是一个B+树节点，一个nnodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描。范围查找等SQL语句。</li></ol><h1 id="Explain语句结果中各个字段分表表示什么"><a href="#Explain语句结果中各个字段分表表示什么" class="headerlink" title="Explain语句结果中各个字段分表表示什么"></a>Explain语句结果中各个字段分表表示什么</h1><div class="table-container"><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值，某些子查询会被优化为join查询，那么出现的id会一样</td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的查询方式(全表扫描、索引)</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的素引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等伯查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>—些额外的信息，比如排序等</td></tr></tbody></table></div><h1 id="lnnodb是如何实现事务的"><a href="#lnnodb是如何实现事务的" class="headerlink" title="lnnodb是如何实现事务的"></a>lnnodb是如何实现事务的</h1><p>Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以一个update语句为例:</p><ol><li>Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中</li><li>执行update语句，修改Buffer Pool中的数据，也就是内存中的数据</li><li>针对update语句生成—个RedoLog对象,并存入LogBuffer中</li><li>针对update语句生成undolog日志，用于事务回滚</li><li>如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中</li><li>如果事务回滚。则利用undolog日志进行回滚</li></ol><h1 id="五、MySQL的索引结构是什么样的-聚簇索引和非聚簇索引又是什么"><a href="#五、MySQL的索引结构是什么样的-聚簇索引和非聚簇索引又是什么" class="headerlink" title="五、MySQL的索引结构是什么样的?聚簇索引和非聚簇索引又是什么?"></a>五、MySQL的索引结构是什么样的?聚簇索引和非聚簇索引又是什么?</h1><p>二叉树-》AVL树-》红黑树-》B-树-》B+树<br>二叉树:每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。<br>AVL树:树中任意节点的两个子树的高度差最大为1<br>红黑树:</p><ol><li>每个节点都是红色或者黑色。</li><li>根节点是黑色。</li><li>每个叶子节点都是黑色的空节点。</li><li>红色节点的父子节点都必须是褐色。</li><li>从任一节点到其每个叶子节点的所有路径都包含相同的黑色节点。<br>B-树:</li><li>B-树的每个非叶子节点的子节点个数都不会超过D(这个D就是B-树的阶)</li><li>所有的叶子节点都在同一层。</li><li>所有节点关键字都是按照递增顺序排列。<br>B+树:</li><li>非叶子节点不存储数据，只进行数据索引。</li><li>所有数据都存储在叶子节点当中。</li><li>每个叶子节点都存有相邻叶子节点的指针。</li><li>叶子节点按照本身关键字从小到大排序。</li></ol><p>聚簇索引就是数据和索引是在一起的。<br>MyISAM使用的是非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址。InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。<br>聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。<br>InnoDB中，如果表定义了PK，那PK就是聚簇索引。如果没有PK，就会找第一个非空的unique列作为聚簇索引。否则，lnnoDB会创建一个隐藏的row-id作为聚簇索引。</p><p><strong>MySQL的覆盖索引和回表</strong><br>如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查询，这样查询速度就可以更快。<br>实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。<br>user (PK id , name ,sex)<br>select count(name) from user ;-&gt;在name字段上建立一个索引。<br>select id , name ,sex from user; -&gt;将name上的索引升级成为(name,sex)的联合索引。</p><h1 id="MySQL的锁有哪些-什么是间隙锁"><a href="#MySQL的锁有哪些-什么是间隙锁" class="headerlink" title="MySQL的锁有哪些?什么是间隙锁?"></a>MySQL的锁有哪些?什么是间隙锁?</h1><p>从锁的粒度来区分<br>1、行锁:加锁粒度小，但是加锁资源开销比较大。InnDB支持。<br>共享锁:读锁。多个事务可以对同一个数据共享同一把锁。持有锁的事务都可以访问数据，但是只能读不能修改。selectxxx LOCK IN SHARE MODE。<br>排他锁:写锁。只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。InnoDB会对update\delete\insert语句自动添加排他锁。SELECT xxx FOR UPDATE。<br>自增锁:通常是针对MySQL当中的自增字段。如果有事务回滚这种情况，数据会回滚，但是自增序列不会回滚。<br>2、表锁:加锁粒度大，加锁资源开销比较小。MylSAM和InnoDB都支持。<br>表共享读锁<br>表排他写锁<br>意向锁:是InnoDB自动添加的一种锁，不需要用户干预。<br>3、全局锁: Flush tables with read lock。加锁之后整个数据库实例都处于只读状态。所有的数据变更操作都会被挂起。一般用于全库备份的时候。<br>常见的锁算法: user. userid ( 1,4.9)update user set xxx where userid=5;REPEATABLE READ间隙锁锁住(5,9)<br>1、记录锁:锁一条具体的数据。<br>2、间隙锁:RR隔离级别下，会加间隙锁。锁一定的范围，而不锁具体的记录。是为了防止产生幻读。(-x,1)(1,4)(4.,9)(9，xxx)<br>3、Next-key :间隙锁+右记录锁。(-xx,1](1,4](4.9](9，xxx)</p><h1 id="MySQL的集群是如何搭建的-读写分离是怎么做的"><a href="#MySQL的集群是如何搭建的-读写分离是怎么做的" class="headerlink" title="MySQL的集群是如何搭建的?读写分离是怎么做的?"></a>MySQL的集群是如何搭建的?读写分离是怎么做的?</h1><p><img src="https://picbed.kirony.xyz/img/主从集群.png" alt="code"></p><ul><li>MySQL通过将主节点的Binlog同步给从节点完成主从之间的数据同步。</li><li>MySQL的主从集群只会将binlog从主节点同步到从节点，而不会反过来同步。由此也就引申出了读写分离的问题。</li><li>因为要保证主从之间的数据一致，写数据的操作只能在主节点完成，而读数据的操作，可以在主节点或者从节点上完成。</li></ul><h1 id="Mysql慢查询该如何优化"><a href="#Mysql慢查询该如何优化" class="headerlink" title="Mysql慢查询该如何优化?"></a>Mysql慢查询该如何优化?</h1><ol><li>检查是否走了索引，如果没有则优化SQL利用索引</li><li>检查所利用的索引，是否是最优索引</li><li>检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据</li><li>检查表中数据是否过多，是否应该进行分库分表了</li><li>检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资瀛</li></ol><h1 id="mysql聚簇和非聚簇索引的区别"><a href="#mysql聚簇和非聚簇索引的区别" class="headerlink" title="mysql聚簇和非聚簇索引的区别"></a>mysql聚簇和非聚簇索引的区别</h1><p>都是B+树的数据结构</p><ul><li>聚簇索引:将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即:只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</li><li>非聚簇索引:叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码看文章。</li></ul><p>InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><p>MyISM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键』辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p><p>如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。</p><h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><p>多版本并发控制:读取数据时通过一种类似玦照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事session会看到自己特定版本的数据，版本链</p><p>MVCC只在READ COMMITTED和REPEATABLEREAD两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容,因为READ UNCOMMITTED总是读取最新的数据行,而不是符合当前事务版本的数据行。而SERIALIZABLE贝会对所有读取的行都加锁。</p><p><strong>聚簇索引记录中有两个必要的隐藏列:</strong></p><ul><li>trx_id:用来存储每次对某条聚簇索引记录进行修改的时候的事务id。</li><li>roll_pointer: 每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</li></ul><p>已提交读和可重复读的区别就在于它们生成ReadView的策略不同。</p><ul><li>开始事务时创建readview，readView维护当前活动的事务id，即未提交的事务id，排序生成一个数组</li><li>访问数据，获取数据中的事务id(获取的是事务id最大的记录)，对比readview:</li><li>如果在readview的左边(比readview都小)，可以访问(在左边意味着该事务已经提交)</li><li>如果在readview的右边(比readview都大）或者就在readview中，不可以访问，获取roll_pointer，取上一版本重新对比(在右边意味着，该事务在readview生成之后出现，在readview中意味着该事务还未提交)</li><li>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个Readview，之后的读都复用之前的Readview。</li><li>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。</li></ul><h1 id="什么是脏读、幻读、不可重复读-要怎么处理"><a href="#什么是脏读、幻读、不可重复读-要怎么处理" class="headerlink" title="什么是脏读、幻读、不可重复读?要怎么处理?"></a>什么是脏读、幻读、不可重复读?要怎么处理?</h1><p>这些问题都是MySQL进行事务并发控制时经常遇到的问题。</p><ul><li>脏读:在事务进行过程中，读到了其他事务未提交的数据。</li><li>不可重复读:在一个事务过程中，多次查询的结果不一致。</li><li>幻读:在一个事务过程中，用同样的操作查询数据，得到的记录数不相同。</li></ul><p>处理的方式有很多种:加锁、事务隔离、Mvcc<br>加锁:</p><ol><li>脏读:在修改时加排他锁，直到事务提交才释放。读取时加共享锁，读完释放锁。</li><li>不可重复读:读数据时加共享锁，写数据时加排他锁。</li><li>幻读:加范围锁。</li></ol><h1 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h1><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。<br><strong>索引的原理:</strong>就是把无序的数据变成有序的查询</p><ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol><h1 id="关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过"><a href="#关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过" class="headerlink" title="关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?"></a>关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?</h1><p>在业务系统中，除了使用主键进行的查询其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。<br>慢查询的优化首先要搞明白慢的原因是什么?是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?<br>所以优化也是针对这三个方向来的</p><ul><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h1 id="Redis单线程为什么这么快"><a href="#Redis单线程为什么这么快" class="headerlink" title="Redis单线程为什么这么快"></a>Redis单线程为什么这么快</h1><p>Redis基于Reactor模式开发了网络事件处理器、哀件事件处理器file event handler。它是单线程的，所以Redis才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性。</p><p>文件事件处理器的结构包含4个部分:多个Socket、IO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。</p><p>多个Socket 可能并发的产生不同的事件，IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中有序、同步取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器。然后一个Socket的事件处理完之后，IO多路复用程序才会将队列中的下一个Socket给事件分派器。文件事件分派器会根据每个Socket当前产生的事件，来选择对应的事件处理器来处理。</p><ol><li>Redis启动初始化时，将连接应答处理器跟AE_READABLE事件关联。</li><li>若一个客户端发起连接，会产生一个AE_READABLE事件，然后由连接应答处理器负责和客户端建立连接，创建客户端对应的socket，同时将这个socket的AE_READABLE事件和命令请求处理器关联，使得客户端可以向主服务器发送命令请求。</li><li>当客户端向Redis发请求时(不管读还是写请求)，客户端socket都会产生一个AE_READABLE事件，触发命令请求处理器。处理器读取客户端的命令内容，然后传给相关程序执行。</li><li>当Redis服务器准备好给客户端的响应数据后，会将socket的AE_WRITABLE事件和命令回复处理器关联，当客户端准备好读取响应数据时，会在socket产生一个AE_WRITABLE事件，由对应命令回复处理器处理，即将准备好的响应数据写入socket，供客户端读取。</li><li>命令回复处理器全部写完到socket后，就会删除该socket的AE_WRITABLE事件和命令回复处理器的映射。</li></ol><p><strong>单线程快的原因：</strong></p><ol><li>纯内存操作</li><li>核心是基于非阻塞的IO多路复用机制</li><li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li></ol><h1 id="redis的持久化机制"><a href="#redis的持久化机制" class="headerlink" title="redis的持久化机制"></a>redis的持久化机制</h1><p>RDB: Redis DataBase 将某一个时刻的内存快照(Snapshot)，以二进制的方式写入磁盘。<br><strong>手动触发:</strong></p><ul><li>save命令，使Redis处于阻塞状态，直到RDB持久化完成，才会响应其他客户端发来的命令，所以在生产环境—定要慎用</li><li>bgsave命令，fork出一个子进程执行持久化，主进程只在fork过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了<br><strong>自动触发:</strong></li><li>save m n :在m秒内，如果有n个键发生改变，则自动触发持久化，通过bgsave执行，如果设置多个、只要满足其一就会触发，配置文件有默认配置(可以注释掉)</li><li>flushall:用于清空redis所有的数据库，flushdb清空当前redis所在库数据(默认是0号数据库)，会清空RDB文件，同时也会生成dump.rdb、内容为空</li><li>主从同步:全量同步时会自动触发bgsave命令，生成rdb发送给从节点<br><strong>优点:</strong></li></ul><ol><li>整个Redis数据库将只包含一个文件dump.rdb，方便持久化。</li><li>容灾性好，方便备份。</li><li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis 的高性能</li><li>相对于数据集大时，比AOF的启动效率更高。<br><strong>缺点:</strong></li><li>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百亳秒，甚至是1秒钟。会占用cpu<br><strong>AOF:</strong>Append Only File 以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘。<br><strong>当不小心使用flushall命令后，如果开启了AOF功能，可以不用跑路，因为flushall不会清理AOF日志</strong></li><li>所有的写命令会追加到AOF缓冲中。</li><li>AOF缓冲区根据对应的策略向硬盘进行同步操作。</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。4、当Redis重启时，可以加载AOF文件进行数据恢复。<br><strong>同步策略:</strong></li></ol><ul><li>每秒同步:异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失</li><li>每修改同步:同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢一条</li><li>不同步:由操作系统控制，可能丢失较多数据<br><strong>优点:</strong></li></ul><ol><li>数据安全</li><li>通过append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题。</li><li>AOF机制的rewrite模式。定期对AOF文件进行重写，以达到压缩的目的<br><strong>缺点:</strong></li><li>AOF文件比RDB文件大，且恢复速度慢。</li><li>数据集大的时候，比rdb 启动效率低。</li><li>运行效率没有RDB高</li></ol><h1 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h1><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p><ul><li><strong>惰性过期:</strong>只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li><strong>定期过期:</strong>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)<br>Redis中同时使用了惰性过期和定期过期两种过期策略。</li></ul><h1 id="Redis分布式锁底层是如何实现的"><a href="#Redis分布式锁底层是如何实现的" class="headerlink" title="Redis分布式锁底层是如何实现的?"></a>Redis分布式锁底层是如何实现的?</h1><ol><li>首先利用setnx来保证:如果key不存在才能获取到锁，如果key存在，则获取不到锁</li><li>然后还要利用lua脚本来保证多个redis操作的原子性</li><li>同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约</li><li>同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</li></ol><h1 id="Redis和Mysql如何保证数据一致"><a href="#Redis和Mysql如何保证数据一致" class="headerlink" title="Redis和Mysql如何保证数据一致"></a>Redis和Mysql如何保证数据一致</h1><ol><li>先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致</li><li>先删涂Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中</li><li>延时双删，步骤是:先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致</li></ol><h1 id="redis集群方案"><a href="#redis集群方案" class="headerlink" title="redis集群方案"></a>redis集群方案</h1><p>主从<br>哨兵模式:<br>sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能:</p><ul><li>集群监控:负责监控redis master和slave 进程是否正常工作。</li><li>消息通知:如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移:如果master node挂掉了，会自动转移到slave node 上。</li><li>配置中心:如果故障转移发生了，通知client客户端新的master地址。</li></ul><p>哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的</li><li>哨兵通常需要3个实例，来保证自己的健壮性。</li><li>哨兵+ redis 主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性。</li><li>对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。<br>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</li></ul><p><strong>方案说明</strong></p><ul><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384个槽位</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li><li>同一分片多个节点间的数据不保持强一致性</li><li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li><li>扩容时需要需要把旧节点的数据迁移一部分到新节点<br>在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另外一个就是加1w的端口号，比如16379。</li></ul><p>16379端口号是用来进行节点间通信的，也就是cluster bus的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带</p><p><strong>优点</strong></p><ul><li>无中心架构，支持动态扩容，对业务透明</li><li>具备Sentinel的监控和自动Failover(故障转移)能力</li><li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li><li>高性能，客户端直连redis服务，免去了proxy代理的损耗<br><strong>缺点</strong></li><li>运维也很复杂，数据迁移需要人工干预</li><li>只能使用0号数据库</li><li>不支持批量操作(pipeline管道操作)</li><li>分布式逻辑和存储模块耦合等</li></ul><p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool<br><strong>优点</strong><br>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强<br><strong>缺点</strong><br>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</p><p>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</p><h1 id="Redis如何配置Key的过期时间-他的实现原理是什么"><a href="#Redis如何配置Key的过期时间-他的实现原理是什么" class="headerlink" title="Redis如何配置Key的过期时间?他的实现原理是什么?"></a>Redis如何配置Key的过期时间?他的实现原理是什么?</h1><p>redis设置key的过期时间:</p><ol><li>EXPIRE</li><li>SETEX<br><strong>实现原理:</strong></li><li>定期删除:每隔一段时间,执行一次删除过期key的操作。</li><li>懒汉式删除:当使用get、getset等指令去获取数据时，判断key是否过期。过期后，就先把key删除，再执行后面的操作。<br>Redis是将两种方式结合来使用。<br>懒汉式删除<br>定期删除:平衡执行频率和执行时长。<br>定期删除时会遍历每个database(默认16个)，检查当前库中指定个数的key(默认是20个)。随机抽查这些key，如果有过期的，就删除。<br>程序中有一个全局变量记录到秒到了哪个数据库。</li></ol><h1 id="布隆过滤器原理，优缺点"><a href="#布隆过滤器原理，优缺点" class="headerlink" title="布隆过滤器原理，优缺点"></a>布隆过滤器原理，优缺点</h1><p>位图: int[10]，每个int类型的整数是4*8=32个bit，则int[10]—共有320 bit，每个bit非o即1，初始化时都是0</p><p>添加数据时，将数据进行hash得到hash值，对应到bit位，将该bit改为1，hash函数可以定义多个，则一个数据添加会将多个(hash函数个数) bit改为1，多个hash函数的目的是减少hash碰撞的概率</p><p>查询数据: hash函数计算得到hash值，对应到bit中，如果有一个为0，则说明数据不在bit中，如果都为1，则该数据可能在bit中<br><strong>优点:</strong></p><ul><li>占用内存小</li><li>增加和查询元素的时间复杂度为:O(K),(K为哈希函数的个数，一般比较小)，与数据量大小无关</li><li>哈希函数相互之间没有关系，方便硬件并行运算</li><li>布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势</li><li>数据量很大时，布隆过滤器可以表示全集</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算<br><strong>缺点:</strong></li><li>误判率，即存在假阳性(False Position)，不能准确判断元素是否在集合中</li><li>不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素</li></ul><h1 id="缓存过期都有哪些策略"><a href="#缓存过期都有哪些策略" class="headerlink" title="缓存过期都有哪些策略?"></a>缓存过期都有哪些策略?</h1><ul><li><p><strong>定时过期:</strong>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好;但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量</p></li><li><p><strong>惰性过期:</strong>只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，但是很消耗内存、许多的过期数据都还存在内存中。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p></li><li><p><strong>定期过期:</strong>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key (是随机的)，并清除其中已过期的key。该策略是定时过期和惰性过期的折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p></li></ul><h1 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h1><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请东而崩掉。可能来源于大量缓存同时过期或缓存重启<br><strong>解决方案:</strong></p><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li><li>缓存预热</li><li>互斥锁</li></ul><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。可能来源于攻击<br><strong>解决方案:</strong></p><ul><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=O的直接拦截;</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒(设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击</li><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li></ul><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。<br><strong>解决方案：</strong></p><ul><li>设置热点数据永远不过期</li><li>加互斥锁</li></ul><h1 id="redis分布式锁实现"><a href="#redis分布式锁实现" class="headerlink" title="redis分布式锁实现"></a>redis分布式锁实现</h1><p>setnx+setex:存在设置超时时间失败的情况，导致死锁一<br>set(key,value,nx,px):将setnx+setex变成原子操作问题:</p><ul><li>任务超时，锁自动释放，导致并发问题。使用redisson解决(看门狗监听，自动续期)</li><li>以及加锁和释放锁不是同一个线程的问题。在value中存入uuid(线程唯一标识)，删除锁时判断该标识(使用lua保证原子操作)</li><li>不可重入，使用redisson解浏(实现机制类似AQS，计数)·异步复制可能造成锁丢失，使用redLock解决</li></ul><ol><li>顺序向五个节点请求加锁</li><li>根据一定的超时时间来推断是不是跳过该节点</li><li>三个节点加锁成功并且花费时间小于锁的有效期</li><li>认定加锁成功</li></ol><h1 id="简述redis九大数据结构"><a href="#简述redis九大数据结构" class="headerlink" title="简述redis九大数据结构"></a>简述redis九大数据结构</h1><ul><li>string:字符串</li><li>List:列表</li><li>Hash:哈希表</li><li>Set:无序集合</li><li>Sorted Set:有序集合</li><li>bitmap:布隆过滤器</li><li>GeoHash:坐标，借助Sorted Set实现，通过zset的score进行排序就可以得到坐标附近的其它元素，通过将score还原成坐标值就可以得到元素的原始坐标</li><li>HyperLogLog:统计不重复数据，用于大数据基数统计</li><li>Streams:内存版的kafka</li></ul><h1 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么"></a>#{}和${}的区别是什么</h1><h1 id="是预编译处理、是占位符，-是字符串替换、是拼接符"><a href="#是预编译处理、是占位符，-是字符串替换、是拼接符" class="headerlink" title="{}是预编译处理、是占位符，${}是字符串替换、是拼接符;"></a>{}是预编译处理、是占位符，${}是字符串替换、是拼接符;</h1><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement来赋值;<br>Mybatis在处理${}时，就是把${}替换成变量的值，调用Statement来赋值;</p><h1 id="的变量替换是在DBMS中、变量替换后，-对应的变量自动加上单引号"><a href="#的变量替换是在DBMS中、变量替换后，-对应的变量自动加上单引号" class="headerlink" title="{}的变量替换是在DBMS中、变量替换后，#{}对应的变量自动加上单引号;"></a>{}的变量替换是在DBMS中、变量替换后，#{}对应的变量自动加上单引号;</h1><p>${}的变量替换是在DBMS外、变量替换后，${}对应的变量不会加上单引号;<br>使用#{}可以有效的防止SQL注入,提高系统安全性。</p><h1 id="ApplicationContext与BeanFactory的区别"><a href="#ApplicationContext与BeanFactory的区别" class="headerlink" title="ApplicationContext与BeanFactory的区别"></a>ApplicationContext与BeanFactory的区别</h1><p>BeanFactory是Spring中非常核心的组件，表示Bean工厂，可以生成Bean，维护Bean，而ApplicationContext继承了BeanFactory，所以ApplicationContext拥有BeanFactory所有的特点，也是一个Bean工厂，但是ApplicationContext除开继承了BeanFactory之外，还继承了诸如<br>EnvironmentCapable、MessageSource、ApplicationEventPublisher等接口，从而ApplicationContext还有获取系统环境变量、国际化、事件发布等功能，这是BeanFactory所不具备的<br><strong>ApplicationContext是BeanFactory的子接口</strong><br>ApplicationContext提供了更完整的功能:</p><ol><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个(有继承关系)上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ol><ul><li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</li><li>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</li><li>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</li><li>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader</li><li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是:BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li></ul><h1 id="Spring-Boot、Spring-MVC和Spring有什么区别"><a href="#Spring-Boot、Spring-MVC和Spring有什么区别" class="headerlink" title="Spring Boot、Spring MVC和Spring有什么区别"></a>Spring Boot、Spring MVC和Spring有什么区别</h1><ul><li>spring是一个IOC容器，用来管理bean的，使用依赖注入(DI)的方式来控制翻转, 可以方便控制整合各种框架，同时利用AOP机制优化了OOP所带来的代码重复问题，将不同类不同方法的共同处理抽取成切面，自动注入给方法执行，例如日志，异常等。</li><li>springmvc是spring对web框架应用的解决方案，通过一个总的前端控制器servlet用来接受请求，定义了一套路由策略(从url到handle的映射)以及适配执行handle，将handle结果使用视图解析技术生成视图展示给前端。</li><li>springboot是spring和springmvc整合到一起的快速开发工具包，能让开发人员更加便捷的开发spring+springmvc应用，采用约定大于配置，摆脱了springmvc开发中繁多的配置难题，同时整合了一系列的解决方案(通过starter机制)，redis、mybatis等在pom中注册依赖即可使用。</li></ul><h1 id="SpringBoot是如何启动Tomcat的"><a href="#SpringBoot是如何启动Tomcat的" class="headerlink" title="SpringBoot是如何启动Tomcat的"></a>SpringBoot是如何启动Tomcat的</h1><ol><li>首先，SpringBoot在启动时会先创建一个Spring容器</li><li>在创建Spring容器过程中，会利用@ConditionalOnClass技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会生成一个启动Tomcat的Bean</li><li>Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端口等，然后启动Tomcat</li></ol><h1 id="SpringBoot中常用注解及其底层实现"><a href="#SpringBoot中常用注解及其底层实现" class="headerlink" title="SpringBoot中常用注解及其底层实现"></a>SpringBoot中常用注解及其底层实现</h1><ol><li>@SpringBootApplication注解:这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是:<ul><li>@SpringBootConfiguration:这个注解实际就是一个@Configuration，表示启动类也是一个配置类</li><li>@EnableAutoConfiguration:向Spring容器中导入了一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean</li><li>@ComponentScan:标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录</li></ul></li><li>@Bean注解:用来定义Bean，类似于XML中的cbean&gt;标签，Spring在启动时，会对加了@Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象</li><li>@Controller、@Service、@ResponseBody、@Autowired都可以说</li></ol><h1 id="SpringBoot中配置文件的加载顺序是怎样的"><a href="#SpringBoot中配置文件的加载顺序是怎样的" class="headerlink" title="SpringBoot中配置文件的加载顺序是怎样的?"></a>SpringBoot中配置文件的加载顺序是怎样的?</h1><p>优先级从高到低，高优先级的配置覆盖低优先级的配置，所有配置会形成互补配置。</p><ol><li>命令行参数。所有的配置都可以在命令行上进行指定;</li><li>Java系统属性(System.getProperties0) ;</li><li>操作系统环境变量;</li><li>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</li><li>jar包内部的application-[profile}.properties或application.yml(带spring.profile)配置文件再来加载不带profile</li><li>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</li><li>jar包内部的application.properties或application.ymI(不带spring.profile)配置文件</li><li>@Configuration注解类上的@PropertySource</li></ol><h1 id="Spring-Boot自动配置原理"><a href="#Spring-Boot自动配置原理" class="headerlink" title="Spring Boot自动配置原理"></a>Spring Boot自动配置原理</h1><p>@import +@Configuration + Spring spi<br>自动配置类由各个starter提供，使用@Configuration + @Bean定义配置类，放到META-INF/spring.factories下使用Spring spi扫描META-INF/spring.factories下的配置类<br>使用@import导入自动配置类<br><img src="https://picbed.kirony.xyz/img/spring自动装配.png" alt="code"></p><h1 id="SpringMVC的底层工作流程"><a href="#SpringMVC的底层工作流程" class="headerlink" title="SpringMVC的底层工作流程"></a>SpringMVC的底层工作流程</h1><ol><li>用户发送请求至前端控制器DispatcherServlet。</li><li>DispatcherServlet收到请求调用HandlerMapping 处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter 处理器适配器。</li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)</li><li>Controller 执行完成返回ModelAndView.</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View。</li><li>DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)。</li><li>DispatcherServlet响应用户。</li></ol><h1 id="Spring-MVC的主要组件"><a href="#Spring-MVC的主要组件" class="headerlink" title="Spring MVC的主要组件"></a>Spring MVC的主要组件</h1><p>Handler:也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可以是类,也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个Handler，只要可以实际处理请求就可以是Handler</p><ol><li><strong>HandlerMapping</strong><br>initHandlerMappings(context)，处理器映射器，根据用户请求的资源uri来查找Handler的。在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行，这就是HandlerMapping需要做的事。</li><li><strong>HandlerAdapter</strong><br>initHandlerAdapters(context)，适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢?这就是HandlerAdapter要做的事情。Handler是用来干活的工具;HandlerMapping用于根据需要干的活找到相应的工具;HandlerAdapter是使用工具干活的人。</li><li><strong>HandlerExceptionResolver</strong><br>initHandlerExceptionResolvers(context)，其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢?这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给render方法进行渲染。</li><li><strong>ViewResolver</strong><br>initViewResolvers(context)，ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html(也可能是其它类型)文件。这里就有两个关键问题:使用哪个模板?用什么技术(规则)填入参数?这其实是ViewResolver主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型)进行渲染，具体的渲染过程则交由不同的视图自己完成。</li><li><strong>RequestToViewNameTranslator</strong><br>initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。RequestToViewNameTranslator在Spring MC容器里只可以配置一个，所以所有request到ViewName的转换规则都要在一个Translator里面全部实现。</li><li><strong>LocaleResolver</strong><br>initLocaleResolver(context)，解析视图需要两个参数:一是视图名，另一个是Locale。视图名是处理器返回的,Locale是从哪里来的?这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale:一是ViewResolver视图解析的时候;二是用到国际化资源或者主题的时候。</li><li><strong>ThemeResolver</strong><br>initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有ThemeResolver、ThemeSource和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了。</li><li><strong>MultipartResolver</strong><br>initMultipartResolver(context)，用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</li><li><strong>FlashMapManager</strong><br>initFlashMapManager(context)，用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</li></ol><h1 id="SpringMVC中的控制器是不是单例模式-如果是，如何保证线程安全"><a href="#SpringMVC中的控制器是不是单例模式-如果是，如何保证线程安全" class="headerlink" title="SpringMVC中的控制器是不是单例模式?如果是，如何保证线程安全?"></a>SpringMVC中的控制器是不是单例模式?如果是，如何保证线程安全?</h1><p>控制器是单例模式。<br>单例模式下就会有线程安全问题。<br>Spring中保证线程安全的方法</p><ol><li>将scop设置成非singleton。prototype, request。</li><li>最好的方式是将控制器设计成无状态模式。在控制器中，不要携带数据。但是可以引用无状态的service和dao。</li></ol><h1 id="spring事务传播机制"><a href="#spring事务传播机制" class="headerlink" title="spring事务传播机制"></a>spring事务传播机制</h1><p>多个事务方法相互调用时,事务如何在这些方法间传播</p><blockquote><p>方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法Al事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</p><ul><li>REQUIRED(Spring默认的事务传播类型):如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</li><li>SUPPORTS:当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</li><li>MANDATORY:当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</li><li>REQUIRES_NEW:创建一个新事务，如果存在当前事务，则挂起该事务。</li><li>NOT_SUPPORTED:以非事务方式执行,如果当前存在事务，则挂起当前事务</li><li>NEVER:不使用事务，如果当前事务存在，则抛出异常</li><li>NESTED:如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样(开启一个事务)</li></ul></blockquote><h1 id="Spring框架中Bean的创建过程是怎样的"><a href="#Spring框架中Bean的创建过程是怎样的" class="headerlink" title="Spring框架中Bean的创建过程是怎样的?"></a>Spring框架中Bean的创建过程是怎样的?</h1><p>首先，简单来说，Spring框架中的Bean经过四个阶段:实例化-》属性赋值-》初始化-》销毁<br>然后:具体来说，Spring中Bean经过了以下几个步骤:</p><ol><li>实例化: new xxx();两个时机:<ol><li>当客户端向容器申请一个Bean时;</li><li>当容器在初始化一个Bean时发现还需要依赖另一个Bean。BeanDefinition对象保存。</li></ol></li><li>设置对象属性(依赖注入): Spring通过BeanDefinition找到对象依赖的其他对象，并将这些对象赋予当前对象。</li><li>处理Aware接口: Spring会检测对象是否实现了xxxAware接口，如果实现了，就会调用对应的方法。BeanNameAware、BeanClassLoaderAware、BeanFactoryAware、ApplicationContextAware</li><li>BeanPostProcessor前置处理:调用BeanPostProcessor的postProcessBeforelnitialization方法</li><li>InitializingBean: Spring检测对象如果实现了这个接口，就会执行他的afterPropertiesSet()方法，定制初始化逻辑。</li><li>init-method: <bean init-method=xxx>如果Spring发现Bean配置了这个属性，就会调用他的配置方法，执行初始化逻辑。@PostConstruct</li><li>BeanPostProcessor后置处理:调用BeanPostProcessor的postProcessAfterInitialization方法<blockquote><p>到这里，这个Bean的创建过程就完成了，Bean已经可以正常使用了</p></blockquote></li><li>DisposableBean: 当Bean实现了这个接口，在对象销毁前就会调用destory()方法。</li><li>destroy-method:<bean destroy-method=xxx>@PreDestroy</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自用网址</title>
      <link href="/posts/34a1c63f.html"/>
      <url>/posts/34a1c63f.html</url>
      
        <content type="html"><![CDATA[<h1 id="动漫网站"><a href="#动漫网站" class="headerlink" title="动漫网站"></a>动漫网站</h1><p><a href="https://www.96ba.com">https://www.96ba.com</a></p><h1 id="网飞源影视"><a href="#网飞源影视" class="headerlink" title="网飞源影视"></a>网飞源影视</h1><p><a href="https://ddys.site">https://ddys.site</a></p><h1 id="提瓦特大地图"><a href="#提瓦特大地图" class="headerlink" title="提瓦特大地图"></a>提瓦特大地图</h1><p><a href="https://webstatic.mihoyo.com/ys/app/interactive-map/index.html">https://webstatic.mihoyo.com/ys/app/interactive-map/index.html</a></p><h1 id="开源影视"><a href="#开源影视" class="headerlink" title="开源影视"></a>开源影视</h1><p><a href="https://www.freeok.vip/">https://www.freeok.vip/</a></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高频面试八股文-上半</title>
      <link href="/posts/874d9b5e.html"/>
      <url>/posts/874d9b5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java中有几种方式来创建线程执行任务"><a href="#Java中有几种方式来创建线程执行任务" class="headerlink" title="Java中有几种方式来创建线程执行任务"></a>Java中有几种方式来创建线程执行任务</h1><p>可以说有一种也可以说有四种，一种是因为Java中创建线程执行的方式本质上都是使用Runnable接口实现；<br>而四种分别是：</p><ul><li>继承Thread类来重写run方法实现</li><li>实现Runnable接口重写run方法</li><li>实现Callable接口使用futureTast实现call方法来创建线程，这种可以返回线程执行结果</li><li>通过线程池创建线程</li></ul><h1 id="为什么不建议使用Executors来创建线程池"><a href="#为什么不建议使用Executors来创建线程池" class="headerlink" title="为什么不建议使用Executors来创建线程池"></a>为什么不建议使用Executors来创建线程池</h1><p>Executors创建线程池的方式是调用LinkedBlockingQueue，它是一个无界阻塞队列，在线程执行任务时，可能会导致任务过多而不停的添加至队列中，而导致系统内存耗尽，最终导致OOM。<br>而SingleThreadExector同样是调用LinkedBlockingQueue，所以建议使用ThreadPoolExector来定义线程池</p><h1 id="线程池有几种状态？每种状态分别代表什么意思？"><a href="#线程池有几种状态？每种状态分别代表什么意思？" class="headerlink" title="线程池有几种状态？每种状态分别代表什么意思？"></a>线程池有几种状态？每种状态分别代表什么意思？</h1><ul><li>RUNNING 正常运行</li><li>SHUTDOWN shutdown() 不会接受新任务，但继续执行</li><li>STOP shutdownnow() 停止运行</li><li>TIDYING terminated() 线程池没有线程运行，进入空方法terminated()</li><li>TERMINATED terminated()执行完</li></ul><h1 id="Sychronized和ReentrantLock有那些区别？"><a href="#Sychronized和ReentrantLock有那些区别？" class="headerlink" title="Sychronized和ReentrantLock有那些区别？"></a>Sychronized和ReentrantLock有那些区别？</h1><h2 id="Sychronized"><a href="#Sychronized" class="headerlink" title="Sychronized"></a>Sychronized</h2><ul><li>Java中的一个关键字</li><li>自动加锁与释放锁</li><li>JVM层面的锁</li><li>非公平锁</li><li>锁的是对象，锁信息保存在对象头中</li><li>底层有锁升级过程</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><ul><li>JDK提供的一个类</li><li>需要手动加锁与释放锁</li><li>API层面的锁</li><li>公平锁或非公平锁</li><li>int类型的state标识来标识锁的状态</li><li>没有锁升级过程</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS是乐观锁，线程执行的时候不会加锁，假设没有冲突去完成某项操作，如果因为冲突失败了就重试，最后直到成功为止。<br>compare and swap多线程访问，在没有加锁的情况下，保证线程一致性的去改变某个值，比如有个变量初始值0，第一个线程读取过来，想加1，在把1往回写的时候需要先去读最新的值，看看还是不是0，如果是，则把值改成1，如果原来的值已经被别的线程动了，改成2了，那么此时cas失败，值还是2。此时第一个线程虽然cas失败了，但是并不会被挂起，而是自旋，他会把最新的2读取，然后+1,再把3写回去的时候依然去判断原来的值是否被别的线程改变，如果改变了继续重复上述步骤。</p><h1 id="ThreadLocal有哪些应用场景？它底层是如何实现的？"><a href="#ThreadLocal有哪些应用场景？它底层是如何实现的？" class="headerlink" title="ThreadLocal有哪些应用场景？它底层是如何实现的？"></a>ThreadLocal有哪些应用场景？它底层是如何实现的？</h1><p>ThreadLocal是JAVA内部提供的一个线程本地储存机制，可以将数据缓存到线程内部，应用于多个类传递数据时的场景，底层是通过ThreadLocalMap实现的，每一个Thread对象都存在一个ThreadLocalMap，其对象名为Map的Key，缓存的数据为Value，但要注意的是ThreadLocal内部使用的是强引用指向的Map，导致使用完以后不会自动回收内存，需要在应用场景结束后手动remove，手动清除Entry对象</p><h1 id="ReentrantLock分为公平锁和非公平锁，那底层分别是如何实现的"><a href="#ReentrantLock分为公平锁和非公平锁，那底层分别是如何实现的" class="headerlink" title="ReentrantLock分为公平锁和非公平锁，那底层分别是如何实现的?"></a>ReentrantLock分为公平锁和非公平锁，那底层分别是如何实现的?</h1><p>首先不管是公平锁和非公平锁，它们的底层实现都会使用AQS来进行排队，它们的区别在于线程在使用lock()方法加锁时:</p><ol><li>如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队，则当前线程也进行排队</li><li>如果是非公平锁，则不会去检查是否有线程在排队，而是直接竞争锁。<br>另外，不管是公平锁还是非公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁只是体现在了线程加锁阶段，而没有体现在线程被唤醒阶段，ReentrantLock是可重入锁，不管是公平锁还是非公平锁都是可重入的。</li></ol><h1 id="Sychronized的锁升级过程是怎样的"><a href="#Sychronized的锁升级过程是怎样的" class="headerlink" title="Sychronized的锁升级过程是怎样的?"></a>Sychronized的锁升级过程是怎样的?</h1><ol><li>偏向锁：在锁对象的对象头中记录当前获取到的锁的线程ID，线程下次来获取直接获取；</li><li>轻量级锁：由偏向锁升级而来，在有一个线程获取锁以后，另一个线程来竞争锁，会导致锁进入自旋状态；</li><li>重量级锁：在多次自旋无果以后依旧没有获取到锁，会从轻量级升级为重量级锁，导致线程阻塞；</li><li>自旋锁：自旋就是在线程获取锁的时候，不会去阻塞线程，而是通过CAS不停获取标记，省去了阻塞和唤醒两个消耗系统资源的步骤，因为CAS是不停的循环获取标记，直到获取成功。</li></ol><h1 id="Tomcat中为什么要使用自定义类加载器"><a href="#Tomcat中为什么要使用自定义类加载器" class="headerlink" title="Tomcat中为什么要使用自定义类加载器?"></a>Tomcat中为什么要使用自定义类加载器?</h1><p>因为Tomcat中可以部署多个应用，而多个应用中可能会出现同名的类，尽管功能不同，但Tomcat启动以后是作为一个进程存在的，所以进程中不允许出现同类名，所以要为每一个应用都生成一个类加载实例WebAppClassLoarder，不同的类加载器可以隔离每个应用的同名类，同时自定义类加载器可以实现热加载。</p><h1 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h1><p>面向对象是一种开发方式，相比与面向过程的连续，它更多的注重于对象本身以及对象所要进行的操作，将相关的数据与方法组合成一个整体来看，虽然不如面向过程简单便捷，但更易于维护与管理。<br><strong>面向对象的三个特性</strong></p><ol><li>封装：对象中的数据与代码可以被封装起来，私有数据与代码不给外部访问，公有的则是内部给外部留下使用方法，对象的内部细节外部无需了解，外部的调用也无需关心与修改内部实现；</li><li>继承：子类可以继承父类的方法，好处是无需对基类的通用方法重复造轮子，同时可以在子类自定义及扩展自己需要的方法，重写是例子；</li><li>多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同，多种逻辑可以用一个方法调用实现，构造方法重载是例子。</li></ol><h1 id="JDK、JRE、JVM的区别"><a href="#JDK、JRE、JVM的区别" class="headerlink" title="JDK、JRE、JVM的区别"></a>JDK、JRE、JVM的区别</h1><ul><li>JVM 虚拟机</li><li>JRE 运行环境 lib类库与jvm</li><li>JDK 开发环境 包含JRE与java工具</li><li>Servlet 经典web开发</li><li>Spring web开发脚手架(框架) 配置地狱</li><li>Spring boot 大部分用默认配置代替的优化版Spring</li><li>Swagger 多人开发中的日志 与前端接口交流</li><li>Redis 缓存数据库</li><li>Mybatis 代替JDBC的数据库整合</li><li>Druid alibaba的数据库监管</li><li>Shiro || Security 用户名密码验证安全框架</li><li>Thymeleaf 前端模板</li><li>zookeeper 分布式的注册中心 需要Dubbo去连接</li><li>Dubbo 分布式开发的工具 可以让B去注册中心使用A注册的服务 负载均衡</li></ul><h1 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h1><ul><li>修饰类时，类不可被继承</li><li>修饰方法时，不可被子类覆盖，但可以重载</li><li>修饰变量时，赋值以后不可改变<ul><li>成员变量:<ul><li>类变量，只能在静态初始块中指定初始值 或声明变量指定初始值；</li><li>成员变量，可以在非静态初始块中初始化或声明变量或构造器初始化；</li></ul></li><li>局部变量：系统不会初始化，需要手动指定，只要在使用前指定默认值即可；</li><li>基本数据类型：赋值不可更改；</li><li>引用类型：引用对象不可更改，但引用的值可以变； <h2 id="为什么局部内部类和匿名内部类只能访问局部final变量"><a href="#为什么局部内部类和匿名内部类只能访问局部final变量" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部final变量?"></a>为什么局部内部类和匿名内部类只能访问局部final变量?</h2></li></ul></li><li>内部类：写在一个类中的独立类，可以调用外部类数据及代码，外部类需要内部类对象来访问成员；</li><li>匿名内部类：只使用一次的匿名内部类，继承父类或实现父类接口，将使用接口的定义子类，重写接口方法，new子类对象，调用重写后方法整合成一个步骤：匿名内部类；</li><li>局部内部类：局部内部类与局部变量一样，不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰。局部内部类只在当前方法中有效。局部内部类中只可以访问当前方法中 final 类型的参数与变量。</li></ul><p>首先需要知道的一点是:内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。<br>这里就会产生问题:当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾:内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期<br>将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢?<br>就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。<br><strong>总结：</strong>本质上是因为内部类在运行结束外部类销毁时，内部类不会因为外部类的销毁而不存在，而内部类依旧存在的情况下仍然在调用之前使用的局部变量，但是变量已经随着方法的销毁而不存在了，所以内部类使用的本质上是变量的copy，所以需要保证两个变量的值相同，使用final关键字使变量的值不会更改。</p><h1 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h1><ul><li>List:有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用lterator取出所有元素，在逐—遍历，还可以使用get(int index)获取指定下表的元素；</li><li>Set:无序，不可重复，最多允许有一个Null元素对象，取元素时只能用lterator接口取得所有元素，在逐一遍历各个元素</li></ul><h1 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h1><p>HashMap的扩展原理是HashMap用一个新的数组替换原来的数组。重新计算原数组的所有数据并插入一个新数组，然后指向新数组。如果阵列在容量扩展前已达到最大值，阈值将直接设置为最大整数返回。<br>hashMap扩容就是重新计算容量，向hashMap不停的添加元素，当hashMap无法装载新的元素，对象将需要扩大数组容量，以便装入更多的元素。</p><ul><li>1.7版本</li></ul><ol><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表上的每个元素</li><li>取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标</li><li>将元素添加到新数组中去</li><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li></ol><ul><li>1.8版本（新增了红黑树）</li></ul><ol><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表或红黑树</li><li>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去</li><li>如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置<br>a. 统计每个下标位置的元素个数<br>b. 如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置<br>c.如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置<br>5.所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li></ol><h1 id="HashMap和HashTable的区别-底层实现是什么"><a href="#HashMap和HashTable的区别-底层实现是什么" class="headerlink" title="HashMap和HashTable的区别? 底层实现是什么?"></a>HashMap和HashTable的区别? 底层实现是什么?</h1><ol><li>区别:<br>(1) HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全;<br>(2) HashMap允许key和value为null，而HashTable不允许</li><li>底层实现:数组+链表实现<br>jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在；</li></ol><ul><li>计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，</li><li>如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组，</li><li>如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表</li><li>key为null，存在下标0的位置数组扩容</li></ul><h1 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h1><ul><li>ArrayList:基于动态数组，连续内存存储，适合下标访问(随机访问)，扩容机制:因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动(往后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList(需要创建大量的node对象)；</li><li>LinkedList:基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐一遍历遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过geti取得某一元素时都需要对list重新进行遍历，性能消耗极大。另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlof对list进行了遍历，当结果为空时会遍历整个列表。</li></ul><h1 id="ConcurrentHashMap的扩容机制"><a href="#ConcurrentHashMap的扩容机制" class="headerlink" title="ConcurrentHashMap的扩容机制"></a>ConcurrentHashMap的扩容机制</h1><p><strong>1.7版本：</strong> ConcurrentHashMap是由一个个Segment对象实现，而扩容则是对在Segment对象中的数组实现扩容操作；</p><ol><li>1.7版本的ConcurrentHashMap是基于Segment分段实现的</li><li>每个Segment相对于一个小型的HashMap</li><li>每个segment内部会进行扩容，和HashMap的扩容逻辑类似 </li><li>先生成新的数组，然后转移元素到新数组中</li><li>扩容的判断也是每个segment内部单独判断的，判断是否超过阈值<br><strong>1.8版本：</strong> ConcurrentHashMap不再基于Segment实现，而是线程生成数组扩容，且支持多个线程同时扩容，扩容前会先判断是否正在进行扩容操作，如果没有，先将key-value放入ConcurrentHashMap中再判断是否超过阀值。</li><li>1.8版本的ConcurrentHashMap不再基于Segment实现</li><li>当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容</li><li>如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容</li><li>ConcurrentHashMap是支持多个线程同时扩容的</li><li>扩容之前也先生成一个新的数组</li><li>在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作</li></ol><h1 id="ConcurrentHashMap原理-jdk7和jdk8版本的区别"><a href="#ConcurrentHashMap原理-jdk7和jdk8版本的区别" class="headerlink" title="ConcurrentHashMap原理,jdk7和jdk8版本的区别"></a>ConcurrentHashMap原理,jdk7和jdk8版本的区别</h1><p><strong>jdk7:</strong><br>数据结构:ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构；</p><p>元素查询:二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部；</p><p>锁: Segment分段锁Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment；</p><p>get方法无需加锁，volatile保证<br><strong>jdk8:</strong><br>数据结构: synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性查找，替换，赋值操作都使用CAS；</p><p>锁:锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作、并发扩容；</p><p>读操作无锁:<br>  Node的val和next使用volatile修饰，读写线程对该变量互相可见数组用volatile修饰，保证扩容时被读线程感知</p><p><strong>volatile:</strong><br>volatile是Java中的关键字，用来修饰会被不同线程访问和修改的变星。JMM(Java内存模型）是围绕并发过程中如何处理可见性、原子性和有序性这3个特征建立起来的，而volatile可以保证其中的两个特性。</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排(保证有序性)</li></ul><h1 id="CopyOnWriteArrayList的底层原理是怎样的"><a href="#CopyOnWriteArrayList的底层原理是怎样的" class="headerlink" title="CopyOnWriteArrayList的底层原理是怎样的"></a>CopyOnWriteArrayList的底层原理是怎样的</h1><p>因为ArrayList本身线程不安全的缘故，并发过程中会导致数据丢失，使用CopyOnWriteArrayList；</p><ol><li>首先CopyOnWiteArrayList内部也是用过数组来实现的，在向CopyOnWriteAraylist添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行</li><li>并且，写操作会加锁，防止出现并发写入丢失数据的问题</li><li>写操作结束之后会把原数组指向新数组</li><li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArraylit会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li></ol><h1 id="String、-StringBuffer、StringBuilder的区别"><a href="#String、-StringBuffer、StringBuilder的区别" class="headerlink" title="String、 StringBuffer、StringBuilder的区别"></a>String、 StringBuffer、StringBuilder的区别</h1><ol><li>String是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer和StringBuilder是可变的</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下stringBuilder效率会更高<br><strong>总结：</strong>区别就是String是字符串，StringBuffer和StringBuilder是操作字符串，但是StringBuffer线程安全，有锁Synchronized。</li></ol><h1 id="String、StringBuffer、StringBuilder区别及使用场景"><a href="#String、StringBuffer、StringBuilder区别及使用场景" class="headerlink" title="String、StringBuffer、StringBuilder区别及使用场景"></a>String、StringBuffer、StringBuilder区别及使用场景</h1><ul><li>string是final修饰的，不可变，每次操作都会产生新的String对象</li><li>stringBuffer和stringBuilder都是在原对象上操作</li><li>stringBuffer是线程安全的，StringBuilder线程不安全的</li><li>stringBuffer方法都是synchronized修饰的</li><li>性能: StringBuilder &gt; stringBuffer &gt; string</li><li>场景:经常需要改变字符串内容时使用后面两个</li><li>优先使用StringBuilder，多线程使用共享变量时使用StringBuffer</li></ul><h1 id="阿里二面-Jdk1-7到Jdk1-8-HashMap发生了什么变化-底层"><a href="#阿里二面-Jdk1-7到Jdk1-8-HashMap发生了什么变化-底层" class="headerlink" title="阿里二面:Jdk1.7到Jdk1.8 HashMap发生了什么变化(底层)?"></a>阿里二面:Jdk1.7到Jdk1.8 HashMap发生了什么变化(底层)?</h1><ol><li>1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率；数组超过64，链表超过8就会启用红黑树</li><li>1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8t中插入key和Vale时需要判断链表示素个数，所以需要遍历锥表统计铤表元索个数，所以正好就直接使用尾插法；</li><li>1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为负载的哈希算法的目的就是提高散列性，来提供HasthMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPu资源。</li></ol><h1 id="阿里二面-Jdk1-7到Jdk1-8-java虚拟机发生了什么变化"><a href="#阿里二面-Jdk1-7到Jdk1-8-java虚拟机发生了什么变化" class="headerlink" title="阿里二面:Jdk1.7到Jdk1.8 java虚拟机发生了什么变化?"></a>阿里二面:Jdk1.7到Jdk1.8 java虚拟机发生了什么变化?</h1><p>1.7中存在永久代，1.8中没有永久代，替换它的是元空间，元空间所占的内存不是在虚拟机内部，而是本地内存空间，这么做的原因是，不管是永久代还是元空间，他们都是方法区的具体实现，之所以元空间所占的内存改成本地内存，官方的说法是为了和Rocit统一，不过额外还有一些原因，比如方法区所存储的类信息通常是比较难确定的，所以对于方法区的大小是比较难指定的，太小了容易出现方法区溢出，太大了又会占用了太多虚拟机的内存空间，而转移到本地内存后则不会影响虚拟机所占用的内存</p><h1 id="阿里一面-说一下HashMap的Put方法"><a href="#阿里一面-说一下HashMap的Put方法" class="headerlink" title="阿里一面:说一下HashMap的Put方法"></a>阿里一面:说一下HashMap的Put方法</h1><p>先说HashMap的Put方法的大体流程;<br>1.根据Key通过哈希算法与与运算得出数组下标<br>⒉如果数组下标位置元素为空，则将key和value封装为Entry对象(JDK1.7中是Entry对象，JDK1.8中是Node对象）并放入该位晋<br>3.如果数组下标位置元素不为空，则要分情况讨论<br>  a.如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中b.如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node，还是链表Node<br>  b.如果是红黑树Node，则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key,如果存在则更新value<br>  c.如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到镞表的最后位置去，因为是尾插法，所以需要遍历镞表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value，当遍历完)表后，将新链表Node插入到链表中，插入到链表后，会看当前链表的节点个数，如果超过了8，那么则会将该链表转成红黑树<br>  d.将key和value封装位Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就介绍PUT方法<br><strong>总结：</strong>本质上就是key根据哈希算法和与算法得出数组下标，无元素存放就封装为1.7：entry对象或1.8：node对象直接放进去，有元素存放1.7直接头插法，1.8则是需要判断链表与红黑树：</p><ul><li>红黑树就封装为红黑树节点放进去，同时判断是否存在当前key来更新value；</li><li>链表封装成链表node尾插法放入，尾插法需要遍历，同时判断是否存在当前key来更新value，放完以后判断链表数量是否超过8，超过则转为红黑树</li><li>最后再判断一边是否扩容</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><p>重载:发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。<br>重写:发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类;如果父类方法访问修饰符为private则子类就不能重写该方法。<br><strong>总结：</strong></p><ul><li>重载的参数一定要不同，可以是个数，次序，类型；</li><li>重写与父类的方法名参数都要一样，返回值与异常小于等于，访问修饰符大于等于，private禁止重写；</li></ul><h1 id="ReentrantLock中tryLock-和lock-方法的区别"><a href="#ReentrantLock中tryLock-和lock-方法的区别" class="headerlink" title="ReentrantLock中tryLock()和lock()方法的区别"></a>ReentrantLock中tryLock()和lock()方法的区别</h1><ul><li>tryLock()表示尝试加锁，可能加到，也可能加不到，该方法不会阻塞线程，如果加到锁则返回true，没有加到则返回false，通常用于自旋锁；</li><li>lock()表示阻塞加锁。线程会阻塞直到加到锁，方法也没有返回值；</li></ul><h1 id="sleep-、wait-、join-、yield-的区别"><a href="#sleep-、wait-、join-、yield-的区别" class="headerlink" title="sleep()、wait()、join()、yield()的区别"></a>sleep()、wait()、join()、yield()的区别</h1><ol><li>锁池<br>所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配。</li><li>等待池<br>当我们调用wait ()方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify ()或notifyAll)后等待池的线程才会开始去竞争锁，notify ()是随机从等待池选出一个线程放到锁池，而notifyAllp)是将等待池的所有线程放到锁池当中</li></ol><h2 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h2><ol><li>sleep是Thread类的静态本地方法，wait则是Object类的本地方法。</li><li>sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。</li><li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。</li><li>sleep不需要被唤醒（休眠之后推出阻塞)，但是wait需要(不指定时间需要被别人中断)。</li><li>sleep一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</li><li>sleep会让出CPU执行时间且强制上下文切换，而wait则不一定，wait后可能还是有机会重新竞争到锁继续执行的。</li></ol><p>yield () 执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行。</p><p>join () 执行后线程进入阻塞状态，例如在线程B中调用线程A的join ()，那线程B会进入到阻塞队列，直到线程A结束或中断线程</p><p><strong>总结：</strong></p><ul><li>sleep是直接强制休眠线程直到指定的时间结束</li><li>wait是让线程进入等待池直到手动notify唤醒或者设置时间</li><li>yield是进入就绪状态，跟sleep差不多强制释放cpu但是保留了接下来可能获取cpu执行的权利</li><li>join是强制一个线程优先插队到另一个线程中，直到插队线程结束或中断</li></ul><h1 id="ThreadLocal的底层原理"><a href="#ThreadLocal的底层原理" class="headerlink" title="ThreadLocal的底层原理"></a>ThreadLocal的底层原理</h1><ol><li>ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据绥存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据</li><li>ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象(注意不是ThreadLocal对象)中都存在一个ThreadLlocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值</li><li>如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key，value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用Threadlocll的remove方法，手动清楚Entry对象</li><li>ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接)</li></ol><h1 id="ThreadLocal的原理和使用场景"><a href="#ThreadLocal的原理和使用场景" class="headerlink" title="ThreadLocal的原理和使用场景"></a>ThreadLocal的原理和使用场景</h1><p>每一个Thread对象均含有一个ThreadLoca1Map类型的成员变量threadLocals，它存储本线程中所有ThreadLocal对象及其对应的值</p><p>ThreadLoca1Map由一个个Entry对象构成</p><p>Entry继承自weakReference<ThreadLocal<?>&gt;，一个Entry由 ThreadLoca1对象和object构成。由此可见,Entry的key是ThreadLocal对象，并且是一个弱引用。当没指向key的强引用后，该key就会被垃圾收集器回收</p><p>当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，将值存储进ThreadLocalMap对象中。</p><p>get方法执行过程类似。ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，获取对应的value。</p><p>由于每一条线程均含有各自私有的ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。</p><p>使用场景:</p><ol><li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li><li>线程间数据隔离</li><li>进行事务操作，用于存储线程事务信息。</li></ol><h1 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a>ThreadLocal内存泄露原因，如何避免</h1><p>内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，</p><p>不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p><p>强引用:使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空问不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p><p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使VM在合适的时间就会回收该对象。</p><p>弱引用:JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</p><p><strong>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal实例,value为线程变量的副本</strong><br>threadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部强引用时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null，而value还存在着强引用，只有thread线程退出以后,value的强引用链条才会断掉，但如果当前线程再迟迟不结束的话，这些key为nul的Entry的value就会一直存在一条强引用链;</p><p><strong>key使用强引用</strong><br>当threadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p><p><strong>key使用弱引用</strong><br>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set(),get()， remove()方法的时候会被清除value值。</p><p>因此,，ThreadLocal内存泄漏的根源是:由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><p><strong>ThreadLocal正确的使用方法</strong></p><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</li></ul><h1 id="阿里一面-如何查看线程死锁"><a href="#阿里一面-如何查看线程死锁" class="headerlink" title="阿里一面:如何查看线程死锁"></a>阿里一面:如何查看线程死锁</h1><ol><li>可以通过jstack命令来进行查看，jstack命令中会显示发生了死锁的线程</li><li>或者两个线程去操作数据库时，数据库发生了死锁，这是可以查询数据库的死锁情况</li></ol><h1 id="阿里一面-线程之间如何进行通讯的"><a href="#阿里一面-线程之间如何进行通讯的" class="headerlink" title="阿里一面:线程之间如何进行通讯的"></a>阿里一面:线程之间如何进行通讯的</h1><ol><li>线程之间可以通过共享内存或基于网络来进行通信</li><li>如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒</li><li>像Java中的wait0、notify0就是阻塞和唤醒</li><li>通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式</li></ol><h1 id="并发、并行、串行的区别"><a href="#并发、并行、串行的区别" class="headerlink" title="并发、并行、串行的区别"></a>并发、并行、串行的区别</h1><ul><li>串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着 <strong>串联</strong></li><li>并行在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行。 <strong>并联</strong></li><li>并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行 <strong>并联加开关</strong></li></ul><h1 id="京东二面-并发编程三要素"><a href="#京东二面-并发编程三要素" class="headerlink" title="京东二面:并发编程三要素?"></a>京东二面:并发编程三要素?</h1><ol><li>原子性:不可分割的操作，多个步骤要保证同时成功或同时失败</li><li>有序性:程序执行的顺序和代码的顺序保持—致</li><li>可用性:—个线程对共享变量的修改，另个线程能立马看到</li></ol><h1 id="Java死锁如何避免"><a href="#Java死锁如何避免" class="headerlink" title="Java死锁如何避免?"></a>Java死锁如何避免?</h1><p><strong>造成死锁的几个原因:</strong></p><ol><li>一个资源每次只能被一个线程使用</li><li>—个线程在阻塞等待某个资源时，不释放已占有资源</li><li>—个线程已经获得的资源，在未使用完之前，不能被强行剥夺4.若干线程形成头尾相接的循环等待资源关系</li></ol><p>这是造成死锁必须要达到的4个条件，如果要避兔死锁，只需要不满足其中某一个条件即可。而其中前3个条件是作为救要符合的条件，所以要避兔死赖僦需要打破第4个条件,不出现循环等待锁的关系。</p><p><strong>在开发过程中:</strong></p><ol><li>要注意加锁顺序，保证每个线程按同样的顺序进行加锁</li><li>要注意加锁时限，可以针对所设置一个超时时间</li><li>要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决</li></ol><h1 id="volatile关键字，他是如何保证可见性，有序性"><a href="#volatile关键字，他是如何保证可见性，有序性" class="headerlink" title="volatile关键字，他是如何保证可见性，有序性"></a>volatile关键字，他是如何保证可见性，有序性</h1><ol><li>对于加了iuolatle关键字的成员变量，在对这个变量进行修改时，会直接将CPU高级缓存中的数据写回到主内存，对这个变量的读取也会直接从主内存中读取，从而保证了可见性</li><li>在对volatile修饰的成员变量进行读写时，会插入内存屏障，而内存屏障可以达到禁止重排序的效果，从而可以保证有序性</li></ol><h1 id="线程池的底层工作原理"><a href="#线程池的底层工作原理" class="headerlink" title="线程池的底层工作原理"></a>线程池的底层工作原理</h1><p>线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时:</p><ol><li>如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</li><li>如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueuc满，并且线程池中的数量等于maximumPoolSize，那么通过handler新指定的策略来处理此任务。</li><li>当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</li></ol><h1 id="JAVA类加载"><a href="#JAVA类加载" class="headerlink" title="JAVA类加载"></a>JAVA类加载</h1><h2 id="JAVA类加载的全过程是怎样的"><a href="#JAVA类加载的全过程是怎样的" class="headerlink" title="JAVA类加载的全过程是怎样的?"></a>JAVA类加载的全过程是怎样的?</h2><ul><li>JAVA的类加载器：父子关系AppClassLoader &lt;- ExtClassLoader &lt;- Bootstrap classloader</li><li>Bootstrap classloader 加载java基础类。默认负责加载%JAVA_HOME%lib下的jar包和class文件；</li><li>Extention classloader 加载JAVA_HONE/ext下的jar包和class类。可通过-D java.ext.dirs另行指定目录；</li><li>AppClassLoader 加载CLASSPATH应用下的Jar包，是自定义加载器的父类。可通过-D java.class.path另行指定目录，是系统类加载器，线程上下文加载器；</li><li>BootStrap classloader 由C++开发，是JVA虚拟机的一部分，本身不是JAVA类。</li><li>string , Int等基础类出BootStrap classloader加载。</li></ul><p>类加载过程:加载-》连接-》初始化<br>加载:把Java的字节码数据加载到JVM内存当中，并映射成JVM认可的数据结构。<br>连接:分为三个小的阶段: </p><ol><li>验证:检查加载到的字节信息是否符合JVM规范。</li><li>准备:创建类或接口的静态变量，并赋初始值半初始化状态</li><li>解析:把符号引用转为直接引用<br>初始化: 与JVM机制无关了，是自己的代码执行过程。</li></ol><h2 id="什么是双亲委派机制"><a href="#什么是双亲委派机制" class="headerlink" title="什么是双亲委派机制?"></a>什么是双亲委派机制?</h2><p>JAVA的类加载器: AppClassloader -&gt; ExtClassloader -&gt;BootStrap Classloader<br>每种类加载器都有他自己的加载目录。<br>JAVA中的类加载器: AppClassLoader, ExtClassLoader -&gt; URLClassLoader -&gt;SecureClassLoader -&gt; ClassLoader<br>每个类加载器对他加载过的类，都是有一个缓存的。<br>双亲委派:向上委托在缓存中查找直到最底层的Bootstrap classloader，还没有找到就向下委托在加载器的路径下查找加载直到返回classpath路径。</p><h3 id="有什么作用"><a href="#有什么作用" class="headerlink" title="有什么作用?"></a>有什么作用?</h3><p>作用:保护JAVA底层的类不会被应用程序覆盖。</p><h2 id="一个对象从加载到JVM，再到被GC清除，都经历了什么过程"><a href="#一个对象从加载到JVM，再到被GC清除，都经历了什么过程" class="headerlink" title="一个对象从加载到JVM，再到被GC清除，都经历了什么过程?"></a>一个对象从加载到JVM，再到被GC清除，都经历了什么过程?</h2><ol><li>用户创建一个对象，首先通过内存中class point找到方法区中的类型信息(元数据区中的class)。</li><li>然后在JVM中实例化对象，在堆中开辟空间，半初始化对象(存在指令重排)。</li><li>对象会分配在堆内存中新生代Eden.然后经过一次Minor GC,对象如果存活就会进入s区，在后续每次GC中，如果对象一直存活就会在S区来回拷贝，每移动一次年龄加一，最大年龄为15，超过一定年龄就会移入老年代。</li><li>直到方法执行结束后栈中指针先移除掉﹔</li><li>堆中的对象经过Full GC，则会被标记为垃圾，然后被GC进程清除。</li></ol><h1 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h1><p><img src="https://picbed.kirony.xyz/img/JVM内存模型.png" alt="code"></p><ul><li>JVM Stack:存放执行java方法的栈帧；</li><li>Native Stack:存放执行本地方法的栈帧；</li><li>程序计数器:每一个线程执行到哪一步，在JVM Stack记录指令的内存地址，在Native Stack中永远为0；</li><li>栈:定义变量的指针，每执行一个java方法都会生成一个栈帧</li><li>堆：存放所有的对象数组；</li><li>新生代：占堆内存的三分之一，默认对象年龄达到15以后进入老年代；</li><li>老年代：占堆内存的三分之二；</li><li>Eden：占新生代的十分之八；</li><li>Survivor：分S1,S2分别十分之一，</li><li>元数据区(MetaSpace)：存放常量、静态变量等，1.8以前属于堆内存，1.8以后移出到操作系统中；</li><li>DirectBuffer:JDK1.4的NIO中引用，调用native本地的方法去操作JVM以外的操作系统的内存。</li></ul><h1 id="JVM有哪些垃圾回收器-他们都是怎么工作的-什么是STW-他都发生在哪些阶段-什么是三色标记-如何解决错标记和漏标记的问题-为什么要设计这么多的垃圾回收器"><a href="#JVM有哪些垃圾回收器-他们都是怎么工作的-什么是STW-他都发生在哪些阶段-什么是三色标记-如何解决错标记和漏标记的问题-为什么要设计这么多的垃圾回收器" class="headerlink" title="JVM有哪些垃圾回收器?他们都是怎么工作的?什么是STW?他都发生在哪些阶段?什么是三色标记?如何解决错标记和漏标记的问题?为什么要设计这么多的垃圾回收器?"></a>JVM有哪些垃圾回收器?他们都是怎么工作的?什么是STW?他都发生在哪些阶段?什么是三色标记?如何解决错标记和漏标记的问题?为什么要设计这么多的垃圾回收器?</h1><p>STW: Stop-The-World。是在垃圾回收算法执行过程当中，需要将JVM内存冻结的一种状态。在STW状态下，JAVA的所有线程都是停止执行的-GC线程除外，native方法可以执行，但是不能与JVM交互。GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。</p><ul><li>分代算法<ul><li>Serial：串行 整体过程简单，需要GC时暂停，GC结束后继续运行；属于早期垃圾回收期，只有一个线程执行，多CPU架构下性能严重不足。</li><li>Parallel：并行 在串行的基础上，增加多线程GC。PS+PO组合是1.8默认的垃圾回收器。多CPU架构下，性能更高。</li><li>CMS：Concurrent Mark Sweep 核心思想是将STW打散，让一部分GC线程与用户线程并发执行，整个GC过程分为四个部分：<ul><li>初始标记阶段：STW只标记出根对象直接引用的对线。</li><li>并发标记：继续标记其他对象，与应用程序是并发执行。</li><li>重新标记：STW对并发执行阶段的对象进行重新标记。</li><li>并发清除：并行。将产生的垃圾清除。清除过程中，应用程序又会不断产生新的垃圾，叫做浮动垃圾，留到下一次GC过程中清除。</li></ul></li></ul></li><li>不分代算法<ul><li>G1 Garbage First 垃圾优先：他的内存模型是实际不分代，但是逻辑上是分代的。在内存模型中，对于堆内存就不再分老年代和新生代，而是划分成一个一个的小内存块，叫做Region。每个Region可以隶属于不同的年代。GC分为四个阶段:<ul><li>第一:初始标记标记出GCRoot直接引用的对象。STW</li><li>第二:标记Region，通过RSet标记出上一个阶段标记的Region引用到的Old区Region,</li><li>第三∶并发标记阶段:跟CMS的步骤是差不多的。只是遍历的范围不再是整个Old区，而只需要遍历第二步标记出来的Region。</li><li>第四:重新标记:跟CMK中的重新标记过程是差不多的。</li><li>第五:垃圾清理:与CMS不同的是，G1可以采用拷贝算法，直接将整个Region中的对象拷贝到另一个Region。而这个阶段，G1只选择垃圾较多的Region来清理，并不是完全清理。|</li></ul></li><li>shennandoah：G1机制类似，了解即可。</li><li>ZGC：与内存大小无关，完全不分代。</li></ul></li></ul><p><strong>CMS的核心算法就是三色标记。</strong><br>三色标记:是一种逻辑上的抽象。将每个内存对象分成三种颜色:黑色:表示自己和成员变量都已经标记完毕。灰色:自己标记完了，但是成员变量还没有完全标记完。白色:自己未标记完。</p><h1 id="怎么确定一个对象到底是不是垃圾-什么是GC-Root"><a href="#怎么确定一个对象到底是不是垃圾-什么是GC-Root" class="headerlink" title="怎么确定一个对象到底是不是垃圾?什么是GC Root?"></a>怎么确定一个对象到底是不是垃圾?什么是GC Root?</h1><p>有两种定位垃圾的方式:</p><ol><li>引用计数:这种方式是给堆内存当中的每个对象记录一个引用个数。引用个数为O的就认为是垃圾。这是早期JDK中使用的方式。引用计数无法解决循环引用的问题。</li><li>根可达算法:这种方式是在内存中，从引用根对象向下一直找引用，找不到的对象就是垃圾。<br><strong>哪些是GC</strong><br>Root? Stack -&gt;JVM Stack, Native Stack,class类,run-time constant pool 常量池, static reference静态变量。</li></ol><h1 id="JVM有哪些垃圾回收算法"><a href="#JVM有哪些垃圾回收算法" class="headerlink" title="JVM有哪些垃圾回收算法?"></a>JVM有哪些垃圾回收算法?</h1><ul><li>MarkSweep标记清除算法:<br>这个算法分为两个阶段，标记阶段:把垃圾内存标记出来，清除阶段:直接将垃圾内存回收。这种算法是比较简单的，但是有个很严重的问题，就是会产生大量的内存碎片,因为</li><li>Copying拷贝算法:<br>为了解决标记清除算法的内存碎片问题，就产生了拷贝算法。拷贝算法将内存分为大小相等的两半，每次只使用其中一半。垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一半内存就可以直接清除。<br>这种算法没有内存碎片，但是他的问题就在于浪费空间。而且，他的效率跟存货对象的个数有关。</li><li>MarkCompack标记压缩算法:<br>为了解决拷贝算法的缺陷，就提出了标记压缩算法。这种算法在标记阶段跟标记清除算法是一样的，但是在完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将端边界以外的所有内存直接清除。<br>这三种算法各有利弊，各自有各自的适合场景。</li></ul><h1 id="JVM中哪些可以作为gc-root"><a href="#JVM中哪些可以作为gc-root" class="headerlink" title="JVM中哪些可以作为gc root"></a>JVM中哪些可以作为gc root</h1><p>什么是gc root，NM在进行垃圾回收时，需要找到“垃圾”对象，也就是没有被引用的对象，但是直接找“垃圾”对象是比较耗时的，所以反过来，先找“非垃圾”对象，也就是正常对象，那么就需要从某些“根”开始去找，根据这些“根”的引用路径找到正常对象，而这些“根”有一个特征，就是它只会引用其他对象，而不会被其他对象引用，例如:栈中的本地变量、方法区中的静态变量、本地方法栈中的变量、正在运行的线程等可以作为gc root。</p><h1 id="如何进行JVM调优-JVM参数有哪些-怎么查看一个JAVA进程的JVM参数-谈谈你了解的JVM参数。如果一个java程序每次运行一段时间后，就变得非常卡顿，你准备如何对他进行优化"><a href="#如何进行JVM调优-JVM参数有哪些-怎么查看一个JAVA进程的JVM参数-谈谈你了解的JVM参数。如果一个java程序每次运行一段时间后，就变得非常卡顿，你准备如何对他进行优化" class="headerlink" title="如何进行JVM调优?JVM参数有哪些?怎么查看一个JAVA进程的JVM参数?谈谈你了解的JVM参数。如果一个java程序每次运行一段时间后，就变得非常卡顿，你准备如何对他进行优化?"></a>如何进行JVM调优?JVM参数有哪些?怎么查看一个JAVA进程的JVM参数?谈谈你了解的JVM参数。如果一个java程序每次运行一段时间后，就变得非常卡顿，你准备如何对他进行优化?</h1><p>JVM调优主要就是通过定制JVM运行参数来提高JAVA应用程度的运行数据<br>JVM参数大致可以分为三类:</p><ol><li>标注指令:-开头，这些是所有的HotSpot都支持的参数。|</li><li>非标准指令:-X开头，这些指令通常是跟特定的HotSpot版本对应的。可以用java -X打印出来。</li><li>不稳定参数:-XX开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大。详细的文档资料非常少。<br>java -XX:+PrintCommandLineFlags :查看当前命令的不稳定指令。<br>java -XX:+PrintFlagslnitial :查看所有不稳定指令的默认值。<br>java -XX:+PrintFlagsFinal:查看所有不稳定指令最终生效的实际值。</li></ol><h1 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h1><p><strong>java中的编译器和解释器:</strong></p><ul><li>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</li><li>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件)，它不面向任何特定的处理器，只面向虚拟机。</li><li>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。</li><li>Java源代码——&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器——&gt;机器可执行的二进制机器码——&gt;程序运行。<br><strong>采用字节码的好处:</strong></li></ul><p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloudConfig分布式配置</title>
      <link href="/posts/6bf1e929.html"/>
      <url>/posts/6bf1e929.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud-config分布式配置概述"><a href="#SpringCloud-config分布式配置概述" class="headerlink" title="SpringCloud config分布式配置概述"></a>SpringCloud config分布式配置概述</h1><p><strong>分布式系统面临的—配置文件的问题</strong><br>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，那上百的的配置文件要修改起来，岂不是要发疯!</p><p><strong>什么是SpringCloud config分布式配置中心</strong><br>Spring Cloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环节提供了一个中心化的外部配置。</p><p>Spring Cloud Config分为<strong>服务端</strong>和<strong>客户端</strong>两部分;</p><p>服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问接口。</p><p>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可以通过git客户端工具来方便的管理和访问配置内容。</p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>通过 config-server 可以连接到git，访问其中的资源和配置</p><h2 id="客户端连接服务端"><a href="#客户端连接服务端" class="headerlink" title="客户端连接服务端"></a>客户端连接服务端</h2><p><strong>系统级别的配置</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">config-client</span> <span class="comment">#需要从git上读取的资源名称，不要后缀</span></span><br><span class="line">            <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">            <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">            <span class="attr">uri: http: / / localhost:</span> <span class="number">3344</span></span><br></pre></td></tr></table></figure></p><p><strong>用户级别的配置</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">springcloud-config-client-3355</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zuul路由网关</title>
      <link href="/posts/1e3b5b04.html"/>
      <url>/posts/1e3b5b04.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Zuul"><a href="#什么是Zuul" class="headerlink" title="什么是Zuul?"></a>什么是Zuul?</h1><p>Zuul包含了对请求的路由和过滤两个最主要的功能:</p><p>其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。<br>注意:Zuul服务最终还是会注册进Eureka<br>提供:代理＋路由＋过滤三大功能!</p><h1 id="zuul能干嘛"><a href="#zuul能干嘛" class="headerlink" title="zuul能干嘛?"></a>zuul能干嘛?</h1><ul><li>路由</li><li>过滤</li></ul><p>启动类实现注解@EnableZuulProxy启动Zuul路由</p><p><strong>zuul的配置文件</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springcloud-zuul</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/,http://localhost:7002/eureka/,http://localhost:7003/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">zuul9527.com</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app.name:</span> <span class="string">www.kirony.xyz</span></span><br><span class="line">  <span class="attr">company.name:</span> <span class="string">kirony.xyz</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">mydept.serviceId:</span> <span class="string">springcloud-provider-dept</span></span><br><span class="line">    <span class="attr">mydept.path:</span> <span class="string">/mydept/**</span></span><br><span class="line">  <span class="attr">ignored-services:</span> <span class="string">springcloud-provider-dept</span> <span class="comment">#不能再使用这个路径访问了</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 路由网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix断路器</title>
      <link href="/posts/6f9cc542.html"/>
      <url>/posts/6f9cc542.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Hystrix"><a href="#什么是Hystrix" class="headerlink" title="什么是Hystrix"></a>什么是Hystrix</h1><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，<strong>向调用方返回一个服务预期的，可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间</strong>，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩</p><p><strong>能干嘛</strong></p><ul><li>服务降级</li><li>服务熔断</li><li>服务限流</li><li>接近实时的监控</li><li>……</li></ul><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p><strong>是什么</strong><br>熔断机制是对应雪崩效应的一种微服务链路保护机制。</p><p>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。|</p><p>在应用层自定义熔断以后的备选方案以后，在主方案上注解使用，同时在启动类上@EnableCircuitBreaker启动断路器</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p><strong>服务熔断是在提供方服务端，服务降级是在消费方客户端</strong></p><h2 id="Hystrix服务监控"><a href="#Hystrix服务监控" class="headerlink" title="Hystrix服务监控"></a>Hystrix服务监控</h2><p>@EnableHystrixDashboard<br>启动类注解开启Hystrix服务监控</p><p>注册监控的Bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">hystrixMetricsStreamServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ServletRegistrationBean</span> <span class="variable">servletRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(<span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>());</span><br><span class="line">    servletRegistrationBean.addUrlMappings(<span class="string">&quot;/actuator/hystrix.stream&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> servletRegistrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>记得需要在开启hystrix断路器@EnableCircuitBreaker的情况下才能获取到监控信息</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>服务熔断:服务端~某个服务超时或者异常，引起熔断~，保险丝~</li><li>服务降级:客户端从整体网站请求负载考虑~，当某个服务熔断或者关闭之后，服务将不再被调用- 此时在客户端，我们可以准备一个FallbackFactory，返回一个默认的值(缺省值)，整体的服务水平下降了，但比直接挂掉强</li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 断路器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ribbon及Feign负载均衡</title>
      <link href="/posts/910ebc59.html"/>
      <url>/posts/910ebc59.html</url>
      
        <content type="html"><![CDATA[<h1 id="ribbon负载均衡"><a href="#ribbon负载均衡" class="headerlink" title="ribbon负载均衡"></a>ribbon负载均衡</h1><h2 id="ribbon是什么？"><a href="#ribbon是什么？" class="headerlink" title="ribbon是什么？"></a>ribbon是什么？</h2><ul><li>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。</li><li>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将NetFlix的中间层服务连接在一起。Ribbon的客户端组件提供一系列完整的配置项如:连接超时、重试等等。简单的说，就是在配置文件中列出LoadBalancer(简称LB:负载均衡）后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法!</li></ul><h2 id="ribbon能干嘛？"><a href="#ribbon能干嘛？" class="headerlink" title="ribbon能干嘛？"></a>ribbon能干嘛？</h2><ul><li>LB，即负载均衡(Load Balance)，在微服务或分布式集群中经常用的一种应用。</li><li>负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。·常见的负载均衡软件有Nginx，Lvs等等</li><li>dubbo、SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义</li><li>负载均衡简单分类:<ul><li>集中式LB<ul><li>即在服务的消费方和提供方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方!</li><li>进程式LB<ul><li>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。</li><li>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址!</li></ul></li></ul></li></ul></li></ul><h1 id="Feign负载均衡"><a href="#Feign负载均衡" class="headerlink" title="Feign负载均衡"></a>Feign负载均衡</h1><p>feign，主要是社区，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法：</p><ol><li>微服务名字【ribbon】</li><li>接口和注解【feign】</li></ol><h2 id="Feign能干什么"><a href="#Feign能干什么" class="headerlink" title="Feign能干什么?"></a>Feign能干什么?</h2><ul><li>Feign旨在使编写Java Http客户端变得更容易</li><li>前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义，<strong>在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它(类似于以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可。）</strong>即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>ribbon更多是符合restful风格的写法，而feign使用的接口方式相比于ribbon代码更为简洁，但性能较低，因为需要在接口多加一层服务，并自动装配到消费者的Controller中。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Config笔记</title>
      <link href="/posts/3d520cf0.html"/>
      <url>/posts/3d520cf0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Config笔记"><a href="#Spring-Config笔记" class="headerlink" title="Spring-Config笔记"></a>Spring-Config笔记</h1><p>结论: springboot所有自动配置都是在启动的时候扫描并加载: spring.factories所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功!</p><p>1.springboot在启动的时候，从类路径下/META-INF/ spring.factories获取指定的值;</p><p>2.将这些自动配置的类导入容器，自动配置就会生效，帮我进行自动配置!</p><p>3.以前我们需要自动配置的东西，现在springboot帮我们做了!</p><p>4.整合javaEE，解决方案和自动配置的东西都在spring-boot-autoconfigure-2.2.0.RELEASE.jar这个包下</p><p>5.它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器;</p><p>6.容器中也会存在非常多的xxxAutoConfiguration的文件(@Bean)，就是这些类给容器中导入了这个场景需要的所有组件;并自动配置，@Configuration, JavaConfig!</p><p>7.有了自动配置类，免去了我们手动编写配置文件的工作!</p><hr><p>这就是自动装配的原理!精髓:</p><p>1)、SpringBoot启动会加载大量的自动配置类</p><p>2)、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中;</p><p>3)、我们再来看这个自动配置类中到底配置了哪些组件;(只要我们要用的组件存在在其中，我们就不需要再手动配置了)</p><p>4)、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可;<br>   xxxxAutoConfigurartion:自动配置类;给容器中添加组件xxxxProperties:封装配置文件中相关属性;</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring-Config </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC笔记</title>
      <link href="/posts/e545fed0.html"/>
      <url>/posts/e545fed0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul><li>jsp前端网页写完以后需要在web.xml注册 </li><li>from action == 数据所要去向的目的地 method == get/post方式</li></ul><h1 id="MVC框架做的事"><a href="#MVC框架做的事" class="headerlink" title="MVC框架做的事"></a>MVC框架做的事</h1><ul><li>将url映射到java类或java类的方法</li><li>封装用户提交的数据</li><li>处理请求—调用相关的业务处理—封装响应数据</li><li>讲响应的数据进行渲染 .jsp/html等表示层数据</li></ul><h1 id="Spring-MVC的特点："><a href="#Spring-MVC的特点：" class="headerlink" title="Spring MVC的特点："></a>Spring MVC的特点：</h1><ol><li>轻量级，简单易学</li><li>高效，基于请求响应的MVC框架</li><li>与Spring的兼容性好，无缝结合</li><li>约定优于配置 怎么写的怎么用</li><li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li><li>简洁灵活</li></ol><h1 id="注解-组件"><a href="#注解-组件" class="headerlink" title="注解 组件"></a>注解 组件</h1><p>@Component   组件<br>@Service     service<br>@Controller  controller<br>@Repository  dao</p><p>@Controller 走视图解析器<br>@RestController 直接返回一个字符串</p><h1 id="spring容器固定配置"><a href="#spring容器固定配置" class="headerlink" title="spring容器固定配置"></a>spring容器固定配置</h1><ol><li>配置DispatcherServlet<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>配置CharacterEncodingFilter 解决spring乱码过滤<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>解决json乱码问题<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        解决json乱码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Spring </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring笔记</title>
      <link href="/posts/97be3275.html"/>
      <url>/posts/97be3275.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring常用依赖"><a href="#Spring常用依赖" class="headerlink" title="Spring常用依赖"></a>Spring常用依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Spring常用注解"><a href="#Spring常用注解" class="headerlink" title="Spring常用注解"></a>Spring常用注解</h1><ul><li>@Autowired：根据bean属性id自动装配</li><li>@Qualifier：(value = “cat111”)在复杂bean情况下根据value的值选择对应beanid自动装配</li><li>@Resource：根据id和属性类型匹配 java原生注解</li><li>Component：组件，放在类上，说明被spring管理了，等效于bean 1.dao [@Repository] 2.service [@Service] 3.controller [@Controller] 组件的延伸用法</li><li>@Configuration 配置类，等效于beans.xml 代表被容器托管</li><li>@Bean 注册一个bean，等效于在xml中写一个bean标签，方法的名字等于bean标签中的id，方法的返回值等于bean标签中的class</li></ul><h1 id="xml与注解"><a href="#xml与注解" class="headerlink" title="xml与注解"></a>xml与注解</h1><p>xml用来管理bean<br>注解完成属性的注入<br>要开启注解支持<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定要扫描的包，这个包下的注解生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zzh.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="整合Spring-Mybatis"><a href="#整合Spring-Mybatis" class="headerlink" title="整合Spring Mybatis"></a>整合Spring Mybatis</h1><p>1、编写数据源配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>autoReconnect=true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br>2、sqlSessionFactory<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        绑定mybatis配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/zzh/mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br>3、sqlSessionTemplate<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        只能使用构造器注入sqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br>4、需要给接口加实现类<br>5、将自己的写实现类，注册到spring<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzh.mapper.UserMapperImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br>6、测试</p><h1 id="spring中的事务管理"><a href="#spring中的事务管理" class="headerlink" title="spring中的事务管理"></a>spring中的事务管理</h1><p>声明式事务：AOP<br>编程式事务：需要在代码中，进行事务的管理。 Try Catch回滚</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC即SSM笔记</title>
      <link href="/posts/2ae5b7ba.html"/>
      <url>/posts/2ae5b7ba.html</url>
      
        <content type="html"><![CDATA[<h1 id="Springmvc项目伊始"><a href="#Springmvc项目伊始" class="headerlink" title="Springmvc项目伊始"></a>Springmvc项目伊始</h1><p>添加pom.xml中的dependency依赖</p><p>整合mybatis层：</p><ul><li>applicationContext.xml</li><li>database.properties</li><li>mybatis-config.xml </li></ul><p>dao包存放mapper及其映射 pojo包实体类 service业务层则是直接return对应mapper的方法</p><p>整合spring层 </p><ul><li>spring-dao.xml</li><li>spring-service.xml</li></ul><p>业务层</p><p>整合springmvc层</p><ul><li>spring-mvc.xml</li></ul><p>也就是controller</p><h1 id="排错思路"><a href="#排错思路" class="headerlink" title="排错思路"></a>排错思路</h1><p>bean不存在</p><p>1.查看这个bean是否注入成功</p><p>2.Junit单元测试，看代码是否能查询出结果 //运行中出现java.sql.SQLException: No suitable driver异常 是因为mysql的url报异常 连不上数据库</p><p>3.在数据库连接正常以后，问题不在底层dao，而是spring</p><p>4.SpringMVC,整合的时候web.xml的DispatcherServlet需要在config里面调用到dao,service,mvc层的所有的bean</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Spring </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB笔记</title>
      <link href="/posts/92731c65.html"/>
      <url>/posts/92731c65.html</url>
      
        <content type="html"><![CDATA[<h1 id="模拟数据源-DAO层"><a href="#模拟数据源-DAO层" class="headerlink" title="模拟数据源 DAO层"></a>模拟数据源 DAO层</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzh.web.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zzh.web.pojo.Department;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟数据库的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Department&gt; departments = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        departments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Department&gt;();</span><br><span class="line"></span><br><span class="line">        departments.put(<span class="number">101</span>,<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">101</span>,<span class="string">&quot;教学部&quot;</span>));</span><br><span class="line">        departments.put(<span class="number">102</span>,<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">102</span>,<span class="string">&quot;市场部&quot;</span>));</span><br><span class="line">        departments.put(<span class="number">103</span>,<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">103</span>,<span class="string">&quot;运营部&quot;</span>));</span><br><span class="line">        departments.put(<span class="number">104</span>,<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">104</span>,<span class="string">&quot;后勤部&quot;</span>));</span><br><span class="line">        departments.put(<span class="number">105</span>,<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">105</span>,<span class="string">&quot;教研部&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Department&gt; <span class="title function_">getDepartments</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> departments.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Department <span class="title function_">getDepartmentById</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> departments.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzh.web.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zzh.web.pojo.Department;</span><br><span class="line"><span class="keyword">import</span> com.zzh.web.pojo.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟数据库的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DepartmentDao departmentDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        employees = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">        employees.put(<span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;A123@qq.com&quot;</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">101</span>, <span class="string">&quot;教学部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">1002</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;B123@qq.com&quot;</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">102</span>, <span class="string">&quot;市场部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">1003</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;C123@qq.com&quot;</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">103</span>, <span class="string">&quot;运营部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">1004</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1004</span>, <span class="string">&quot;DD&quot;</span>, <span class="string">&quot;D123@qq.com&quot;</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">104</span>, <span class="string">&quot;后勤部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">1005</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1005</span>, <span class="string">&quot;EE&quot;</span>, <span class="string">&quot;E123@qq.com&quot;</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="number">105</span>, <span class="string">&quot;教研部&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自增id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">initId</span> <span class="operator">=</span> <span class="number">1006</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加员工</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (employee.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            employee.setId(initId++);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------进行前&quot;</span>);</span><br><span class="line">        employee.setDepartment(departmentDao.getDepartmentById(employee.getDepartment().getId()));</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------进行后&quot;</span>);</span><br><span class="line">        employees.put(employee.getId(),employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部员工信息</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> employees.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过id查询员工</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">getEmployeeById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> employees.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        employees.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.实体类字段需要与数据库对应</p><p>2.实体类的数据类型需要与数据库对应</p><p>3.莫名其妙的thymeleaf语法居然可以使用:<br>th:if=”${dept.getDid()} eq ${emp.getDepartment()}” th:text=”${dept.getDepartmentName()}<br>这行代码的逻辑为if (a == b) { text = c; } </p><p>th:if可能在前端上可以用作if的逻辑判断，没有试过使用其他<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;emp:$&#123;emps&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.getId()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.getLastName()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.getEmail()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.getGender()==1?&#x27;男&#x27;:&#x27;女&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:each</span>=<span class="string">&quot;dept:$&#123;departments&#125;&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;dept.getDid()&#125; eq $&#123;emp.getDepartment()&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;dept.getDepartmentName()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(emp.getBirth(),&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-primary&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/emp/&#125;+$&#123;emp.getId()&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-danger&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/deleteEmp/&#125;+$&#123;emp.getId()&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="shiro安全框架的使用"><a href="#shiro安全框架的使用" class="headerlink" title="shiro安全框架的使用"></a>shiro安全框架的使用</h1><p>filterMap.put(“/emp”,”perms[user:add]”);前面一个参数需要的是RequestMapping里面的跳转路径，得到的是那个路径下的Controller操作以及数据。</p><p>anon:无需认证就可以访问<br>authc:必须认证了才能访问<br>user:必须拥有记住我功能才能使用<br>perms:拥有对某个资源的权限才能访问<br>role:拥有某个角色权限才能访问<br>logout:注销</p><p>doGetAuthenticationInfo:认证<br>doGetAuthentizationInfo:授权</p><p>表对应类<br>字段对应属性<br>行记录对应对象</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka服务注册与发现</title>
      <link href="/posts/56f9c10f.html"/>
      <url>/posts/56f9c10f.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Eureka"><a href="#什么是Eureka" class="headerlink" title="什么是Eureka"></a>什么是Eureka</h1><p>Netflix在设计Eureka时,遵循的就是AP原则<br>CAP原则：</p><ul><li>C - consistency 强一致性</li><li>A - availalility 可用性</li><li>P - partition tolerance 分区容错性</li></ul><p>CAP核心理论：一个分布式系统不可能同时很好的满足一致性，可用性，和分区容错性三个需求。</p><p>CA - 单点集群，满足一致性，可用性，通常在可拓展性上不太强大<br>CP - 满足一致性，分区容错性的系统，通常性能不是特别的高<br>AP - 满足可用性，分区容错性，通过对数据一致性要求低一些。</p><p>Eureka是Netflix的一个子模块，也是核心模块之一。Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心工比如Zookeeper;</p><h1 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h1><ul><li>Eureka的基本架构<ul><li>SpringCloud封装了NetFlix公司开发的Eureka模块来实现服务注册和发现（对比Zookeeper)</li><li>Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心。</li><li>而系统中的其他微服务。使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，SpringCloud的一些其他模块（比如Zuul)就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑;</li></ul></li><li>和Dubbo架构对比<ul><li>Eureka包含两个组件: Eureka Server和Eureka client 。</li><li>Eureka Server提供服务注册服务，各个节点启动后，会在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会村粗所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</li><li>Eureka Client是一个lava客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳（默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉（默认周期为90秒)</li></ul></li><li>三大角色<ul><li>Eureka Server:提供服务的注册于发现。zookeeper</li><li>Service Provider:将自身服务注册到Eureka中，从而使消费方能够找到。</li><li>Service Consumer:服务消费方从Eureka中获取注册服务列表，从而找到消费服务。</li></ul></li></ul><h1 id="Eureka的自我保护机制"><a href="#Eureka的自我保护机制" class="headerlink" title="Eureka的自我保护机制"></a>Eureka的自我保护机制</h1><p><strong>一句话总结就是︰某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存! 好死不如赖活着！</strong></p><ul><li>默认情况下，当eurek sever在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（默认是90秒），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启(因为在开发过程中不会修改eureka注册中心)，当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和RenewS(last min)，当后者(最后一分钟收到的心跳数)小于前者(心跳阈值）的时候，触发保护机制，会出现红色的警报∶ENERGENCVIEUREKANAY BE ITMCORRECTLY CLAINTNGINSTAICES ARE UP MHEN THEY’RE NOT.RENENALS ARE LESSER THAN THRESHOLD AND HEINCE THE TISTAICES ARE NOT BE6ING EXPIRED 1U5T T0 BESAFE．从警告中可以看到，eureka认为虽然收不到实例的心跳，但它认为实例还是健康的，eureka会保护这些实例，不会把它们从注册表中删掉,</li><li>该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务，如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka sever了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。所以, eureka sever在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。</li><li>但是我们在开发测试阶段，需要频繁地重启发布，如果触发了保护机制，则旧的服务实例没有被删除，这时请求有可能跑到旧的实例中，而该实例已经关闭了，这就导致请求错误，影响开发测试。所以，在开发测试阶段，我们可以把自我保护模式关闭，只需在eureka server配置文件中加上如下配置即可:eureka.server.enable-self-preservation=false <strong>【不推荐关闭自我保护机制】</strong></li><li>详细内容可以参考下这篇博客内容:<a href="https://blog.csdn.net/wudiyong22/article/details/80827594">https://blog.csdn.net/wudiyong22/article/details/80827594</a></li></ul><h1 id="回顾CAP原则"><a href="#回顾CAP原则" class="headerlink" title="回顾CAP原则"></a>回顾CAP原则</h1><p>RDBMS(Mysql、Oracle、sqlServer) ===&gt; ACID<br>NoSQL(redis、mongdb) ===&gt; CAP<br><strong>ACID是什么</strong></p><ul><li>A(Atomicity)原子性. </li><li>C (Consistency)一致性· </li><li>I (lsolation)隔离性· </li><li>D (Durability)持久性</li></ul><p><strong>CAP是什么</strong></p><ul><li>C - consistency 强一致性</li><li>A - availalility 可用性</li><li>P - partition tolerance 分区容错性</li></ul><h1 id="作为服务注册中心，Eureka比zookeeper好在哪里"><a href="#作为服务注册中心，Eureka比zookeeper好在哪里" class="headerlink" title="作为服务注册中心，Eureka比zookeeper好在哪里?"></a>作为服务注册中心，Eureka比zookeeper好在哪里?</h1><p>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A (可用性)、P(容错性)。由于分区容错性P在分布式系统中是必须要保证的，因此我们只能在A和C之间进行权衡。</p><ul><li>Zookeeper保证的是CP;</li><li>Eureka保证的是AP;</li></ul><p><strong>Zookeeper保证的是CP</strong><br>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30~120s，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得水集群失去master节点是较大概率会发生的事件，虽然服务最终能够恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><p><strong>Eureka保证的是AP</strong><br>Eureka看明白了这一点，因此在设计时就优先保证可用性。IEureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况:</p><ol><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上(即保证当前节点依然可用</li><li>当网络稳定时，当前实例新的注册信息会被同步到其他节点中</li></ol><p><strong>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪</strong></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发中的常用注解</title>
      <link href="/posts/d6c31760.html"/>
      <url>/posts/d6c31760.html</url>
      
        <content type="html"><![CDATA[<h1 id="现阶段Spring中的常用开发注解"><a href="#现阶段Spring中的常用开发注解" class="headerlink" title="现阶段Spring中的常用开发注解"></a>现阶段Spring中的常用开发注解</h1><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><ol><li>@Data //使用这个注解可以省去实体类中大量的get()、 set()、 toString()</li><li>@NoArgsConstructor //无参构造</li><li>@Accessors(chain = true) //链式写法 dept.setDeptNo(11).setDname(‘ssss’).setDb_source(‘001’)</li><li>@AllArgsConstructor //有参构造</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前情知识提要及常见问题</title>
      <link href="/posts/db7ac38.html"/>
      <url>/posts/db7ac38.html</url>
      
        <content type="html"><![CDATA[<h1 id="串一下自己学过的东西"><a href="#串一下自己学过的东西" class="headerlink" title="串一下自己学过的东西"></a>串一下自己学过的东西</h1><ul><li>JavaSE</li><li>数据库</li><li>前端</li><li>Servlet</li><li>Http</li><li>Mybatis</li><li>Spring</li><li>SpringMVC</li><li>SpringBoot</li><li>Dubbo、Zookeeper、分布式</li><li>Maven、git</li><li>Ajax、json</li><li>…../</li></ul><h1 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h1><h2 id="三层架构-MVC"><a href="#三层架构-MVC" class="headerlink" title="三层架构+MVC"></a>三层架构+MVC</h2><p><strong>框架：</strong></p><pre><code>Spring IOC AOP //简化ssm的代码SpringBoot 新一代的JavaEE开发标准，自动装配 //简化Spring的配置模块化开发</code></pre><p><strong>微服务架构的四个问题：</strong></p><ol><li>服务很多，客户端怎么访问？</li><li>这么多服务？服务之间如何通信？</li><li>这么多服务？怎么治理？</li><li>服务挂了怎么办？</li></ol><p><strong>解决方案</strong></p><pre><code>Spring Cloud 生态圈 基于SpringBoot</code></pre><ol><li><p>Spring Cloud NetFlix — 多数使用，一站式操作，解决大部分问题，但停更：<br>api网关，zuul组件；<br>Feign —-HttpClinet —— Http通信方式，同步，阻塞；<br>服务注册发现：Eureka；<br>熔断机制：Hystrix；</p></li><li><p>Apache Dubbo Zookeeper — 半自动，需要整合：<br>API：没有，第三方组件实现或自己实现；<br>Duboo：RPC通信框架；<br>Zookeeper：服务注册；<br>无熔断机制：借助Hystrix；<br>Duboo方案并不完善</p></li><li><p>Spring Cloud Alibaba — 新的一站式解决方案，更简单：<br>新概念：服务网格 Server Mesh;<br>istio;</p></li></ol><p><strong>总结：</strong></p><ol><li>API</li><li>HTTP,RPC</li><li>注册与发现</li><li>熔断机制</li></ol><p>分布式网络并不可靠，所以需要解决方案</p><p>常见面试题：</p><ol><li>什么是微服务?</li><li>微服务之间是如何独立通讯的?  </li><li>SpringCloud和 Dubbo有哪些区别?</li><li>SpringBoot和SpringCloud，请你谈谈对他们的理解</li><li>什么是服务熔断?什么是服务降级</li><li>微服务的优缺点是分别是什么?说下你在项目开发中遇到的坑</li><li>你所知道的微服务技术栈有哪些?请列举一二</li><li>eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别?</li></ol><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><ul><li>知识点</li><li>看看面试题</li><li>微服务和微服务架构</li><li>基础工程 RestTemplate</li><li>Eureka AP<ul><li>集群配置</li><li>对比Zookeeper CP</li></ul></li><li>Ribbon IRule</li><li>Feign 接口，社区要求，更加面向接口编程</li><li>Hystrix<ul><li>熔断</li><li>降级</li><li>dashboard</li></ul></li><li>Zuul</li><li>Spring Cloud Config C-S-GIT</li></ul><ol><li>导入依赖</li><li>编写配置</li><li>@Enablexxx</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫名刷到的段子</title>
      <link href="/posts/1f02d5b6.html"/>
      <url>/posts/1f02d5b6.html</url>
      
        <content type="html"><![CDATA[<h1 id="一些奇奇怪怪的语言"><a href="#一些奇奇怪怪的语言" class="headerlink" title="一些奇奇怪怪的语言"></a>一些奇奇怪怪的语言</h1><h2 id="土味"><a href="#土味" class="headerlink" title="土味"></a>土味</h2><p>想和橘子去100个城市来99个拥抱看98场日落要97次接吻拍96张照片买95朵玫瑰去94家餐馆看93次大海走92条小巷打91次雨伞还要90场牵手种89个草莓盖88次被子递87杯温水热86次剩饭看85次电影做84顿午饭切83个水果吃82次甜品喝81次暖茶要80次的拥抱吃79遍烧烤烤78次肉串涮77次火锅来76次海鲜吃75种小吃参74场晚宴喝73杯喜酒吃72次西餐尝71颗糖果给你70枚香吻荡69遍秋千看68次日出躺67次草地看66次星空闻65次头发抱64次肩胛吻63次脸颊亲62次锁骨咬61次耳朵然后60次相拥看59场鬼片喝58杯奶茶吃57桶米花逛56个商厦打55次的士坐54次公交等53次地铁开52次自驾站51遍路灯睡50次怀里去49个鬼屋看48场表演逗47只动物坐46次飞车玩45次激流滑44次滑梯坐43次飞椅转42次陀螺吊41次吊索然后40个接吻捂39次肚子揉38次肩膀捶37次后背捏36次小腿暖35次脚丫摸34次脑袋撮33次肋骨挠32次手心逗31场大笑然后30次拥吻放29个气球钓28只大鱼玩27次飞镖放26次风筝冲25次瀑布滑24艘小船蹦23场蹦极跳22次跳伞漂21次河流在20次么么骑19次单车看18场大雪玩17遍飞艇去16次森林探15个峡谷踏14个小溪爬13座高山看12个沙漠坐11次轮船写10封情书唱9首情歌堆8个雪人摘7朵野花看6场流星许5个愿醉4次酒养3只狗吵2场架爱1辈子投0个币</p><h2 id="真诚"><a href="#真诚" class="headerlink" title="真诚"></a>真诚</h2><p>对不起，我知道你不会原谅我了，我最先给你带来的伤害让你受了太大的委屈，对不起我给你诚恳的道歉，拉拉扯扯也纠缠你半年了，我也真的累了，我一直在祈求你的原谅，骂你，各种说你，对不起，是我的原因，由爱生恨那会我没有给我的做法考虑后果，跟我分开之后你就变了一个人，一个我完全不认识的人，以前的你我可以哄好，花点时间可以哄好，现在你真的变了，另外一个你，我知道大部分原因是因为我，我知道我现在不管说什么都不可能再有机会了，那就好好道个别吧，虽然我们现实在一起的时间很短，但是那段时间发生的事情我一辈子应该都不会忘；我记得你给我戴的小手链（后来因为粗心就给掉了）记得你经常带我去吃冒菜，每次都辣的满头大汗，记得我们晚上去抓小田螺，你傻傻的拿了一个田螺和一个福寿螺给我区分；记得有人欺负我了你给我出头；记得我们晚上去网吧通宵一起打游戏；记得你那会带我出去蹭饭（哈哈哈那会真的好开心给你掏田螺肉吃，很幸福）；记得每天出门不管干嘛不管天气多热你都会挽着我的手……等等等等这段回忆真的就好像昨天才发生我真的永远不不会忘记你爱我的样子，你处处护着我的样子，我记得你不爱吃葱花，有什么不开心都喜欢憋着，而且特别喜欢吃辣…等等如果后来我们好好处了，我好好珍惜你，我们肯定可以结婚的，我坚信，可是事与愿违，我们还是走到了最不想看到的样子，我现在也知道我的那个她，她回不来了，永远回不来了，永远活在我的记忆里，我爱你，自始至终都很爱你，怪就怪我犹豫了，想太多了，对不起，如果还能从来，我会抓着你的手再也不分开，不管在哪里我们都在一起，，，，遗憾还是会有的，你现在属于别人了那我就祝你幸福，，过的要很好才可以，答应我一定做到，，，，嗯，，就这样吧！！！再见了xxx</p><h2 id="开喷"><a href="#开喷" class="headerlink" title="开喷"></a>开喷</h2><p>群里的某个人，做人别他妈太过分了，真的，你在背后这么说我 如果不是别人跑来亲口跟我说，我还真不知道你这么走嘴，大家都是因为这个群而认识的，做事真的不要太过分，换位思考下如果我也这么说你，你会怎么想，话我撂这儿了，我还把你当好朋友，有什么事情和你分享，呵呵 你居然背后说我长得帅，说我有才华人又好又专一又浪漫， 搞得现在好多女的加我，没意思，真的！</p><h2 id="Emo"><a href="#Emo" class="headerlink" title="Emo"></a>Emo</h2><p>我喜欢的从来都不是乌龙茶的味道，我只记得那是我第一次陪她上街时买的第一杯水，我那时候从没买过奶茶，我不知道什么好喝，我又不想丢了面子，只能点一个看上去比较冷门适合男性喝的黄金乌龙，我只喝过那一次，我再没买到过，去过很多地方都没在买到过，我只记得那晚回去时我合着略带苦味的乌龙，在炎炎夏日的夜晚她穿着裙子，吃着零食跟我讲回去干什么，我看着窗外握着她的手，我以为这样的生活会持续很久，我从来都不是真的喜欢乌龙茶，我只是在喝的时候能借着那一点点的苦味想起那个曾经很爱我的女孩。对我来说，乌龙茶的味道是夏日晚风中夹带的一丝花香的甜味，是我在最爱她时对未来的憧憬，是我还未陷入淤泥时新鲜的空气。</p><h2 id="Conner的傻言傻语"><a href="#Conner的傻言傻语" class="headerlink" title="Conner的傻言傻语"></a>Conner的傻言傻语</h2><p>很内向 吃饭都要钻桌底<br>很内向 不敢牵别人老公的手<br>很内向 去超市买东西不敢给钱<br>很内向 路上不敢亲别人女朋友<br>很内向 坐公交不敢说下车 都是开窗户下去<br>很内向 上课不敢看黑板只趴桌子睡觉<br>很内向 刚刚被人踩了一脚 我习惯性地说了谢谢<br>很内向 撕包装纸都不敢用牙齿<br>很内向 见到前任 都得下跪磕个头<br>很内向 出门头装兜里<br>很内向 买完东西不敢跟老板打照面悄悄走<br>很内向 在路上看到银行不敢去抢<br>很内向 上班都得等到下班再去<br>很内向 上网课的时候不敢开麦骂老师<br>很内向 恋爱都让别人帮忙谈</p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL总结</title>
      <link href="/posts/54ed288e.html"/>
      <url>/posts/54ed288e.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL的总结"><a href="#MySQL的总结" class="headerlink" title="MySQL的总结"></a>MySQL的总结</h1><p><strong>操作数据库</strong>：<br>create database [if not exists] 数据库名<br>drop database [if exists] 数据库名<br>use 数据库名<br>show databases ： 查看所有数据库</p><p><strong>创建数据库</strong>：<br>Create table [if not exists] 表名(<br>字段名 类型 【属性】 【索引】 【注释】，<br>字段名 类型 【属性】 【索引】 【注释】<br>)ENGINE=INNODB DEFAULT CHARSET=utf8</p><p><strong>修改和删除表字段</strong>：<br>修改表名：alter table 旧表名 rename as 新表名<br>增加表字段：alter table 表名 add 字段名 列属性<br>修改表字段：alter table 表名 modify 字段名 列属性[]<br>删除表字段：alter table 表名 drop 字段名<br>删除表：drop table if exists 表名</p><p><strong>MySQL数据管理</strong>：<br>insert into 表名【字段1，字段2】 values 【值1，值2】<br>update 表名 set 字段1=值1，字段2=值2 where 【条件】<br>delete from 表名 where 【条件】 （TRUNCATE：自增列计数器归零，不影响事务）</p><p>去重 distinct</p><p>模糊查询：Like %（0到任意字符） _ (一个字符)</p><p>联表查询：Inner join / left join / right join on 【两表共有的属性】</p><p>分页：limit 起始值，页面大小</p><p>排序：Order by 【字段名】 ASC/DESC</p><p>子查询：使用子查询代替要联表，查询过程有内向外</p><p>分组和过滤： Group by 字段名 Having 平均分&gt;80</p><p><strong>常用函数</strong>：<br>Select Now（）；当前时间<br>Select CURDATE（）；当前日期<br>Select COUNT（）；计数<br>Select SUM/AVG/MAX/MIN（）；</p><p>MD5加密：pwd = MD5(pwd)</p><p><strong>事务原则</strong>：ACID<br>A 原子性：要么都成功，要么都失败。<br>C 一致性：事务前后数据保持一致。<br>I 隔离性：事务间互不干扰。<br>D 持久性：一旦提交不可逆，持久化到数据库。</p><p><strong>隔离导致问题</strong>：<br>脏读：一个事务读取了另一个事务未提交的数据。<br>不可重复读：一个事务内多次读取某一行数据不同。<br>幻读：一个事务内读取到别的事务插入的数据，导致前后读取不一。</p><p>关闭自动提交：SET autocommit = 0；<br>开启事务：START TRANSACTION<br>回滚：ROLLBACK<br>提交事务：COMMIT</p><p><strong>索引</strong>：<br>主键索引：唯一标识，不可重复，仅有一列。<br>唯一索引：避免重复列，可以多个，每个列都可为唯一索引。<br>常规索引：默认的，index，key关键字来设置。<br>全文索引：快速定位数据，特定引擎才有，MYISAM</p><p>CREATE INDEX 索引名 ON 表（字段）<br>CREATE INDEX id_app_user_name ON app_user(‘name’)</p><p><strong>索引原则</strong>：<br>不是越多越好，小数据量不需要，索引加在常用查询的字段上。</p><p>MySQL备份：mysqldump</p><p><strong>三大范式</strong>：<br>第一范式(1NF)：保证每一列不可再分。<br>第二范式(2NF)：满足第一范式，每张表只描述一件事。<br>第三范式(3NF)：满足第一第二范式，表中各列均与主键直接相关，不可间接。</p><p><strong>JDBC</strong>：</p><p>加载驱动 Class.forName（“com.mysql.jdbc.Driver”）<br>用户信息和Url：url = “jdbc:mysql://localhost:3306/jdbcStudy?userUnicode=true&amp;characterEncoding=utf8&amp;userSSL=true”<br>获取数据库连接：DriverManager.getConnection(url,username,password)<br>执行SQL的对象：statement = connection.createStatement();<br>编写sql语句。<br>执行sql：statement.executeQuery(sql) 、executeUpdate(sql)<br>释放连接。<br>PrepareStatement：<br>防止SQL注入问题，利用 ？占位符代替参数。<br>conn.prepareStatement(sql)：预编译sql，但不执行。<br>手动给占位符参数赋值，开始执行sql，st.executeUpdate()</p><p><strong>数据库连接池</strong>：<br>DBCP、C3P0、Druid<br>最小连接数：10 最大连接数：15 等待超时：100ms<br>数据库连接池在初始化时将创建一定数量的数据库连接放到池中，其数量由最小数据库连接数决定。<br>无论这些连接是否被使用，连接池始终保持有这么多的连接数量。<br>连接池的最大连接数量决定了连接池占有的最大连接数，当应用程序向连接池请求的连接数超过最大数，请求将加入等待队列。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的七个核心参数</title>
      <link href="/posts/6d609b23.html"/>
      <url>/posts/6d609b23.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程池七个核心参数"><a href="#线程池七个核心参数" class="headerlink" title="线程池七个核心参数"></a>线程池七个核心参数</h1><p><strong>corePoolSize</strong>： 线程池中常驻核心线程数，即使这些线程处理空闲状态，他们也不会被销毁。</p><p><strong>maximumPoolSize</strong>： 线程池能够容纳同时执行的最大线程数，此值大于等于1。一个任务被提交到线程池以后，首先会找有没有空闲并且存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会放到工作队列中，直到工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。工作队列满，且线程数等于最大线程数，此时再提交任务则会调用拒绝策略。</p><p><strong>keepAliveTime</strong>： 当线程空闲时间达到keepAliveTime值时，多余的线程会被销毁直到只剩下corePoolSize个线程为止。默认情况下：只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用，直到线程中的线程数不大于corepoolSIze。</p><p><strong>unit</strong>： 空闲线程存活时间单位，keepAliveTime的计量单位。</p><p><strong>workQueue</strong>： 工作队列，任务被提交给线程池时，会先进入工作队列，任务调度时再从工作队列中取出。</p><p><strong>threadFactory</strong>： 线程工厂，用来创建线程，可以用来设定线程名，是否为守护线程等。</p><p><strong>handler</strong>： 拒绝策略，当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时，对任务的拒绝方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                            <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                            TimeUnit unit,</span></span><br><span class="line"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                            ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                            RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">          keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">      <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="built_in">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot入门案例</title>
      <link href="/posts/8d0ee66e.html"/>
      <url>/posts/8d0ee66e.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-Boot介绍"><a href="#1-Spring-Boot介绍" class="headerlink" title="1. Spring Boot介绍"></a>1. Spring Boot介绍</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p><p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p><p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p><p>Spring Boot让我们的Spring应用变的更轻量化。</p><p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p><p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p><p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p><p><strong>总结一下Spring Boot的主要优点：</strong></p><ol><li>为所有Spring开发者更快的入门</li><li>开箱即用，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化Web项目</li><li>没有冗余代码生成和XML配置的要求</li><li>统一的依赖管理</li><li>自动装配，更易使用，更易扩展</li></ol><h2 id="1-2-使用版本说明"><a href="#1-2-使用版本说明" class="headerlink" title="1.2 使用版本说明"></a>1.2 使用版本说明</h2><p>Springboot版本：使用最新的2.5.0版本</p><p>教程参考了官方文档进行制作，权威。</p><p>其他依赖版本：</p><pre><code>1. Maven  需求：3.5+   2. JDK 需求  8+   3. Spring Framework 5.3.7以上版本   4. Tomcat 9.0   5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中</code></pre><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h1><p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p><p>教程使用的Idea版本：2019.3</p><h2 id="2-1-创建基础项目"><a href="#2-1-创建基础项目" class="headerlink" title="2.1 创建基础项目"></a>2.1 创建基础项目</h2><p><strong>第一步：</strong> 创建maven项目</p><p>pom.xml :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xiaopizhu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloSpringBoot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p><p>此时的工程结构为：</p><p><img src="https://static.zzhzlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png" alt="image20210523173241557.png"></p><p><strong>第二步：</strong> 添加web依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p><p><strong>第三步：</strong> 编写启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaopizhu.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HelloApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p><p><strong>第四步：</strong> 运行启动类的main方法</p><p><img src="https://static.zzhzlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png" alt="image20210523173712142.png"></p><p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p><p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8082</span></span><br></pre></td></tr></table></figure><p><strong>第六步：</strong> 重新运行</p><p><img src="https://static.zzhzlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png" alt="image20210523174011613.png"></p><p>此时的项目结构为：</p><p><img src="https://static.zzhzlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png" alt="image20210523174032053.png"></p><p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p><p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p><p><strong>src/test/java:</strong>  测试代码</p><h2 id="2-2-编写一个Http接口"><a href="#2-2-编写一个Http接口" class="headerlink" title="2.2 编写一个Http接口"></a>2.2 编写一个Http接口</h2><p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaopizhu.springboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;boot&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello spring boot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意包名，必须在启动类所在的包名下。</strong></p><p><strong>第二步： </strong> 重启程序，使用postman或者直接在浏览器输入<a href="http://localhost:8082/hello/boot">http://localhost:8082/hello/boot</a></p><p>得到结果：hello spring boot</p><h2 id="2-3-编写单元测试用例"><a href="#2-3-编写单元测试用例" class="headerlink" title="2.3 编写单元测试用例"></a>2.3 编写单元测试用例</h2><p><strong>第一步： </strong> 添加spring boot测试依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二步：</strong> 在src/test 下，编写测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaopizhu.springboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.equalTo;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeEach</span><span class="params">()</span>&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> <span class="title class_">HelloController</span>()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/hello/boot&quot;</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(equalTo(<span class="string">&quot;hello spring boot&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p><h2 id="2-4-打包为jar运行"><a href="#2-4-打包为jar运行" class="headerlink" title="2.4 打包为jar运行"></a>2.4 打包为jar运行</h2><p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p><p><img src="https://static.zzhzlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png" alt="image20210523181737720.png"></p><p><strong>第二步： </strong> 打开cmd：找到jar对应的目录</p><p>输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar helloSpringBoot-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://static.zzhzlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png" alt="image20210523182426404.png"></p><p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入<a href="http://localhost:8082/hello/boot">http://localhost:8082/hello/boot</a></p><p>得到结果：hello spring boot</p><h2 id="2-5-查看jar包内容"><a href="#2-5-查看jar包内容" class="headerlink" title="2.5 查看jar包内容"></a>2.5 查看jar包内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h1><ol><li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li><li>通过修改配置文件，更改端口号</li><li>编写了测试用例</li><li>打包jar包运行</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 后端 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element相关</title>
      <link href="/posts/8242b56e.html"/>
      <url>/posts/8242b56e.html</url>
      
        <content type="html"><![CDATA[<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>本节将介绍如何在项目中使用 Element。</p><h3 id="使用-Starter-Kit"><a href="#使用-Starter-Kit" class="headerlink" title="使用 Starter Kit"></a>使用 Starter Kit</h3><p>我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。</p><p>如果不希望使用我们提供的模板，请继续阅读。</p><h3 id="使用-vue-cli"><a href="#使用-vue-cli" class="headerlink" title="使用 vue-cli"></a>使用 vue-cli</h3><p>我们还可以使用 vue-cli 初始化项目，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm i -g vue-cli</span><br><span class="line">&gt; mkdir my-project &amp;&amp; cd my-project</span><br><span class="line">&gt; vue init webpack</span><br><span class="line">&gt; npm i &amp;&amp; npm i element-ui</span><br></pre></td></tr></table></figure><h3 id="引入-Element"><a href="#引入-Element" class="headerlink" title="引入 Element"></a>引入 Element</h3><p>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</p><h4 id="完整引入"><a href="#完整引入" class="headerlink" title="完整引入"></a>完整引入</h4><p>在 main.js 中写入以下内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</p><h4 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h4><p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p>]]></content>
      
      
      <categories>
          
          <category> Element </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 后端 </tag>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的介绍</title>
      <link href="/posts/64699d9c.html"/>
      <url>/posts/64699d9c.html</url>
      
        <content type="html"><![CDATA[<h1 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><p>如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。<br>如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。</p><h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><blockquote><p>官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。</p></blockquote><p>尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。</p><h1 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h1><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA面试总结</title>
      <link href="/posts/a6d74da3.html"/>
      <url>/posts/a6d74da3.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA面试总结"><a href="#JAVA面试总结" class="headerlink" title="JAVA面试总结"></a>JAVA面试总结</h1><h2 id="请简要介绍一下你的项目？"><a href="#请简要介绍一下你的项目？" class="headerlink" title="请简要介绍一下你的项目？"></a><strong>请简要介绍一下你的项目？</strong></h2><p>这个项目的整体结构来源于牛客网，主要使用了Springboot、Mybatis、MySQL、Redis、Kafka、等工具。主要实现了用户的注册、登录、发帖、点赞、系统通知、按热度排序、搜索等功能。另外引入了redis数据库来提升网站的整体性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知：当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。</p><h2 id="什么是Spring框架？"><a href="#什么是Spring框架？" class="headerlink" title="什么是Spring框架？"></a><strong>什么是Spring框架？</strong></h2><p>有很多模块组成，利用这些模块可以方便开发工作。这些模块是：核心容器（spring core)/数据访问和集成(Spring JDBC)/Web(Spring Web/MVC)/AOP(Spring Aop)/消息模块/测试模块(Spring Test)等。</p><h2 id="对Spring-IoC的理解"><a href="#对Spring-IoC的理解" class="headerlink" title="对Spring IoC的理解"></a><strong>对Spring IoC的理解</strong></h2><p>IoC的意思是控制反转，是一种设计思想，把需要在程序中手动创建对象的控制权交给了Spring框架。IoC的载体是IoC容器，本质是一个工厂，数据结构上来看是一个Map，用来存放着各种对象。当我们创建一个对象时，只需要配置好配置文件/注解，而不用担心对象是怎么被创建出来的。</p><p>IoC的优点：降低耦合，对象被容器管理需要两份数据：你的对象定义 + 配置文件，对象间的关系体现在配置文件，不会直接产生耦合。</p><h2 id="什么是DAO"><a href="#什么是DAO" class="headerlink" title="什么是DAO"></a><strong>什么是DAO</strong></h2><p>data access object，存放数据库访问对象。</p><h2 id="Spring中关于Bean的注解"><a href="#Spring中关于Bean的注解" class="headerlink" title="Spring中关于Bean的注解"></a><strong>Spring中关于Bean的注解</strong></h2><p>四种常见Bean<br>@Controller @Repository @Service @Component一般来说Bean只会被容器初始化一次，@PostConstruct：初始化前调用 @PreDestroy：销毁之前<br>如何使用Bean<br>bean通过容器管理，不需要我们实例化，如果要使用某个bean，使用依赖注入 @Autowired</p><h2 id="Spring-MVC是什么，是怎样的工作流程"><a href="#Spring-MVC是什么，是怎样的工作流程" class="headerlink" title="Spring MVC是什么，是怎样的工作流程"></a><strong>Spring MVC是什么，是怎样的工作流程</strong></h2><p>服务器分为表现层/业务层/数据层，其中Spring MVC是工作在表现层，作用是接收/解析用户发送的请求，调用对应的业务类，根据业务类返回的结果（ModelAndView)，调用view进行视图渲染，并将渲染后的View返回给请求者。具体分为以下8步。</p><ol><li>客户端（浏览器）发送请求给前端处理器（DispatcherServlet)(发送请求，响应结果)；</li><li>DispatcherServlet根据请求信息调用HandlerMapping，查找到对应的Handler；</li><li>查找到对应的Handler(也就是Controller)后，由HandlerAdapter适配器处理；</li><li>HandlerAdapter根据Handler来调用真正的Controller；</li><li>Controller进行业务处理，返回ModelAndView对象，Model是数据对象，View是逻辑上的View；</li><li>ViewResolver根据逻辑view找到实际view；</li><li>DispatcherServlet把Model传给view进行视图渲染，然后返回给请求者。</li></ol><p>C - Controller：控制器。接受用户请求，调用 Model 处理，然后选择合适的View给客户。<br>M - Model：模型。业务处理模型，接受Controller的调遣，处理业务，处理数据。<br>V - View：视图。返回给客户看的结果。</p><h2 id="DispatcherServlet处理流程？"><a href="#DispatcherServlet处理流程？" class="headerlink" title="DispatcherServlet处理流程？"></a><strong>DispatcherServlet处理流程？</strong></h2><p>DispatcherServlet 处理流程：<br>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。DispatcherServlet 是前端控制器，配置在web.xml文件中，Servlet依自已定义的具体规则拦截匹配的请求，分发到目标Controller来处理。 初始化 DispatcherServlet时，该框架在web应用程序WEB-INF目录中寻找一个名为[servlet-名称]-servlet.xml的文件，并在那里定义相关的Beans，重写在全局中定义的任何Beans。在看DispatcherServlet 类之前，我们先来看一下请求处理的大致流程：</p><ol><li>Tomcat 启动，对 DispatcherServlet 进行实例化，然后调用它的 init() 方法进行初始化，在这个初始化过程中完成了：对 web.xml 中初始化参数的加载；建立 WebApplicationContext(SpringMVC的IOC容器)；进行组件的初始化；</li><li>客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理；</li><li>DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler(执行程序，如Controller中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器)封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler则退出循环；</li><li>DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象；</li><li>执行 HandlerExecutionChain 中所有拦截器的 preHandler() 方法，然后再利用HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的postHandler() 方法；</li><li>利用 ViewResolver 将 ModelAndView 或是 Exception（可解析成 ModelAndView）解析成View，然后 View 会调用 render() 方法再根据 ModelAndView 中的数据渲染出页面；</li><li>最后再依次调用拦截器的 afterCompletion() 方法，这一次请求就结束了。</li></ol><p>拦截器的作用<br>目的：让未登录用户不能访问某些页面<br>原理：在方法前标注自定义注解，拦截所有的请求，只处理带有该注解的方法。</p><h2 id="什么是SSM框架？"><a href="#什么是SSM框架？" class="headerlink" title="什么是SSM框架？"></a><strong>什么是SSM框架？</strong></h2><p>包括Spring + Spring MVC(和Spring天生集成) + MyBatis（帮你和数据库打交道的框架，简单的设置，你就可以像Java一样，操作数据库了）</p><h2 id="怎么实现注册功能的？"><a href="#怎么实现注册功能的？" class="headerlink" title="怎么实现注册功能的？"></a><strong>怎么实现注册功能的？</strong></h2><p>根据请求来拆解功能</p><ol><li>打开注册网页</li><li>把注册的信息发送给服务器（点注册）</li><li>把激活邮件发送给邮箱</li><li>利用激活链接打开网页</li></ol><p>每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层</p><h2 id="什么是Interceptor，在项目的哪里使用到了Interceptor"><a href="#什么是Interceptor，在项目的哪里使用到了Interceptor" class="headerlink" title="什么是Interceptor，在项目的哪里使用到了Interceptor?"></a><strong>什么是Interceptor，在项目的哪里使用到了Interceptor?</strong></h2><p>Interceptor是SpringMVC的处理器（handler)拦截器，用于对处理器进行预处理和后处理。本项目中，每次请求都会检查request中的login_ticket，把找到的user信息存放在协程中，并在完成处理后，自动释放。（方便的进行用户信息取用）</p><h2 id="使用什么技术生成验证码"><a href="#使用什么技术生成验证码" class="headerlink" title="使用什么技术生成验证码?"></a><strong>使用什么技术生成验证码?</strong></h2><p>使用Kaptcha包，可随机生成字符和图片。</p><h2 id="如何检查登陆状态"><a href="#如何检查登陆状态" class="headerlink" title="如何检查登陆状态"></a><strong>如何检查登陆状态</strong></h2><p>加拦截器注解。</p><h2 id="如何实现敏感词过滤"><a href="#如何实现敏感词过滤" class="headerlink" title="如何实现敏感词过滤"></a><strong>如何实现敏感词过滤</strong></h2><p>使用前缀树（字典树）存储敏感词，对text中的敏感词实现替换。</p><h2 id="什么是Ajax，应用在项目哪些地方？"><a href="#什么是Ajax，应用在项目哪些地方？" class="headerlink" title="什么是Ajax，应用在项目哪些地方？"></a><strong>什么是Ajax，应用在项目哪些地方？</strong></h2><p>ajax指异步的json和xml技术，不是一门新的语言，而是使用现有技术的新方法。最大的特点是：不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。<br>项目中：帖子发布成功/失败的提示，使用到ajax</p><h2 id="什么是事务，事务的四大特性。"><a href="#什么是事务，事务的四大特性。" class="headerlink" title="什么是事务，事务的四大特性。"></a><strong>什么是事务，事务的四大特性。</strong></h2><p>定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>事物的四大特性-ACID：<br>A：原子性，事务是最小的执行单位，不允许被分割，事务的全部操作要么全部提交成功，要么全部失败回滚。<br>C：一致性，数据库在事务执行前后保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果相同。<br>I ：隔离性，一个事务所作的修改在最终提交前，对其他事务是不可见的。避免多个事物交叉执行所导致的数据不一致问题。<br>D（Duability）：持久性，一旦事务提交，所做的修改将被永远保存到数据库中。即使系统发生崩溃，事务执行的结构也不能丢失。</p><h2 id="怎么利用Spring实现事务管理"><a href="#怎么利用Spring实现事务管理" class="headerlink" title="怎么利用Spring实现事务管理"></a><strong>怎么利用Spring实现事务管理</strong></h2><p>Spring管理事务忽略了底层数据库的结构，非常方便。有两种方式：注解（类型，传播方式）/编程式事务（override)。</p><h2 id="是怎样实现统一捕获异常的？"><a href="#是怎样实现统一捕获异常的？" class="headerlink" title="是怎样实现统一捕获异常的？"></a><strong>是怎样实现统一捕获异常的？</strong></h2><p>在SpringBoot的项目某一路径下，加上对应的错误页面，发生错误时自动会跳转。服务器的三层结构中，错误会层层向上传递，所以只需要在表现层（controller)统一处理错误即可。<br>方法：在controller中加上advice包，并通过注解@ControllerAdvice和@ExceptionHandler，统一捕获异常。</p><h2 id="是怎样实现统一记录日志的？"><a href="#是怎样实现统一记录日志的？" class="headerlink" title="是怎样实现统一记录日志的？"></a><strong>是怎样实现统一记录日志的？</strong></h2><p>使用了AOP技术（面向切面编程），这里使用到的是SpringAOP。 AOP技术能够将哪些与业务，但是为业务模块共同调用的逻辑或责任（比如事务处理，日志记录，权限控制等），封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和维护性。 SpringAOP本质上基于动态代理，当要代理的对象实现了某接口，会使用JDK动态代理，在运行时通过创建接口的代理实例，织入代码。当要代理的对象没有实现接口，则使用Cglib技术（编译时增强），通过子类代理织入代码。</p><h2 id="什么是Redis，Redis有哪些优点？"><a href="#什么是Redis，Redis有哪些优点？" class="headerlink" title="什么是Redis，Redis有哪些优点？"></a><strong>什么是Redis，Redis有哪些优点？</strong></h2><p>概念：redis是一个非关系型数据库，数据存储在内存中，读写速度快。可以存储键和五种不同类型值的映射。只能以字符串为键，值支持：字符串，列表，无序集合，有序集合，hash散列表。<br>优点：由于数据存储在内存中，读写速度非常快，满足高性能，高并发的系统要求。与Java原生的map/guava相比，支持分布式缓存。与memcached相比，支持更丰富的数据类型，且支持数据持久化。</p><h2 id="Redis分布式集群架构"><a href="#Redis分布式集群架构" class="headerlink" title="Redis分布式集群架构"></a><strong>Redis分布式集群架构</strong></h2><p>典型的分片+复制</p><h2 id="怎么往Spring框架中配置Redis，介绍常见的Redis操作"><a href="#怎么往Spring框架中配置Redis，介绍常见的Redis操作" class="headerlink" title="怎么往Spring框架中配置Redis，介绍常见的Redis操作"></a><strong>怎么往Spring框架中配置Redis，介绍常见的Redis操作</strong></h2><p>如何配置：<br>1，导入jar包<br>2，配置端口，以及配置类redisTemplate（注入连接工厂/设置序列化方式（json））<br>常见操作<br>Value类型：redisTemplate.opsForValue().set(redisKey, 1)，redisTemplate.opsForValue().get(redisKey)， redisTemplate.opsForValue().increment(redisKey)，<br>Hash类型：redisTemplate.opsForHash().put(redisKey, “id”, 1)， 还有get等操作<br>List类型：redisTemplate.opsForList().leftPush(redisKey, 101)， 还有size, index, range， leftPop等操作<br>Set类型：add, size, pop, members等操作<br>Zset类型：redisTemplate.opsForZSet().add(redisKey, “Linda”, 92), 有socre，rank，reverseRank， range等操作<br>操作key：可以delete，以及设置过期时间<br>同时支持绑定操作，支持事务（编程式事务，在事务中一般不包含查询）<br>为什么不包含查询：redis事务就是一系列命令的批量操作，批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p><h2 id="项目中Redis的作用"><a href="#项目中Redis的作用" class="headerlink" title="项目中Redis的作用"></a><strong>项目中Redis的作用</strong></h2><p>1、事务操作：redisTemplate直接调用opfor…来操作redis数据库，每执行一条命令是要重新拿一个连接，因此很耗资源，让一个连接直接执行多条语句的方法就是使用SessionCallback，同样作用的还有RedisCallback，但不常用。<br>2、使用redis存储验证码：</p><p>因为验证码需要频繁的进行访问与刷新，因此对性能的要求较高；<br>验证码不需要永久保存，通常在很短的时间后就会失效；<br>分布式部署的时候，存在session共享的问题。<br>3、使用redis存储登录凭证：<br>因为后台在每次处理请求的时候都要查询用户的登录凭证，访问的频率非常高，因此需要使用redis存储。<br>4、使用redis缓存用户信息：<br>因为后台在每次处理请求的时候都要根据用户的凭证用户信息，访问的频率非常高。<br>5、Redis可以使用zset对需要排序的数据进行自定义的排序。</p><p>怎样存储的点赞/关注/缓存用户数据<br>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID<br>关注使用zSet类型存储，key为被关注者，set保存关注者以及关注时间为score<br>缓存用户数据使用Value类型，key为用userID得到的key，value为user对象（设置过期时间，且数据修改时需要清除缓存）</p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a><strong>什么是消息队列</strong></h2><p>消息队列是一个存放消息的容器，生产者把消息放在队列中，消费者从消息队列中取出数据。消息队列的主要功能（优点）在于：</p><p>解耦：生产者只负责把消息放在队列中，而不用关心谁去使用它。<br>异步：生产者把消息放在队列中后即可返回，而不用一个个的通知消费者去执行，消费者是异步的获取消息的。<br>限流：生产者一次性产生大量的数据时，不会给消费者造成压力，消费者可以根据自身的能力，去消息队列中取数据。<br>消息队列作为信息传递的中间件，需要注意哪些问题？<br>1、高可用：因为消息队列如果宕机，会导致整个系统不可用。（分布式/集群的现成支持）<br>2、数据持久化：防止数据丢失<br>3、如何取数据：消息队列主动通知或者消费者轮询。</p><h2 id="Java中的blockingqueue，可以提供线程间的消息队列"><a href="#Java中的blockingqueue，可以提供线程间的消息队列" class="headerlink" title="Java中的blockingqueue，可以提供线程间的消息队列"></a><strong>Java中的blockingqueue，可以提供线程间的消息队列</strong></h2><p>BQ也是生产者与消费者模式，属于点对点式消息队列？（一个消息只会被消费一次）Blocking Queue构建了一个桥梁，能够解决生产速度/消费速度不匹配问题。阻塞的时候只是在那里等着，但是不会占用CPU资源，对性能不会有影响。</p><h2 id="什么是Kafka，有哪些功能和应用场景？"><a href="#什么是Kafka，有哪些功能和应用场景？" class="headerlink" title="什么是Kafka，有哪些功能和应用场景？"></a><strong>什么是Kafka，有哪些功能和应用场景？</strong></h2><p>Kafka为分布式流处理平台。流处理是指对不断产生的动态数据流实时处理，基于分布式内存，具有数据处理快速，高效，低延迟的特性。</p><p>Kafka简介：Kafka是一种消息队列，主要用来处理大量数据状态下的消息队列，一般用来做日志的处理，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景<br>特点：</p><p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。<br>可扩展性：kafka集群支持热扩展<br>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失<br>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）<br>高并发：支持数千个客户端同时读写<br>Kafka主要提供的功能包括：消息系统，日志收集，用户行为跟踪，流式数据处理。</p><h2 id="Kafka的基础架构"><a href="#Kafka的基础架构" class="headerlink" title="Kafka的基础架构"></a><strong>Kafka的基础架构</strong></h2><p>Producer：消息生产者，向Kafka中发布消息的角色。<br>Consumer：消息消费者，即从Kafka中拉取消息消费的客户端。<br>Consumer Group：消费者组，消费者组则是一组中存在多个消费者，消费者消费Broker中当前Topic的不同分区中的消息，消费者组之间互不影响，所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。某一个分区中的消息只能够一个消费者组中的一个消费者所消费<br>Broker：经纪人，一台Kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。<br>Topic：主题，可以理解为一个队列，生产者和消费者都是面向一个Topic<br>Partition：分区，为了实现扩展性，一个非常大的Topic可以分布到多个Broker上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列(分区有序，不能保证全局有序)<br>Replica：副本Replication，为保证集群中某个节点发生故障，节点上的Partition数据不丢失，Kafka可以正常的工作，Kafka提供了副本机制，一个Topic的每个分区有若干个副本，一个Leader和多个Follower<br>Leader：每个分区多个副本的主角色，生产者发送数据的对象，以及消费者消费数据的对象都是Leader。<br>Follower：每个分区多个副本的从角色，实时的从Leader中同步数据，保持和Leader数据的同步，Leader发生故障的时候，某个Follower会成为新的Leader。</p><h2 id="Kafka的消息模型，以及常见术语"><a href="#Kafka的消息模型，以及常见术语" class="headerlink" title="Kafka的消息模型，以及常见术语"></a><strong>Kafka的消息模型，以及常见术语</strong></h2><p>消息模型：发布-订阅模型，消费者订阅了某一主题（topic）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。<br>Topic：主题，类似于文件夹，用来存放不同的数据。<br>Partition：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。<br>Offset：消息在Partition中的存放位置。<br>Broker：可以理解为kafka集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着topic1的leader， topic2的follower等等。</p><h2 id="在项目哪里用到了Kafka？"><a href="#在项目哪里用到了Kafka？" class="headerlink" title="在项目哪里用到了Kafka？"></a><strong>在项目哪里用到了Kafka？</strong></h2><p>当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了Kafka，具体来说，先定义了生产者类和消费者类，其中生产者被点赞/评论/关注功能对应的Controller使用，产生消息。而消费者负责消息（message）到来时，把消息存到数据库内。</p><h2 id="什么是ElasticSearch，存储原理，功能，特点"><a href="#什么是ElasticSearch，存储原理，功能，特点" class="headerlink" title="什么是ElasticSearch，存储原理，功能，特点"></a><strong>什么是ElasticSearch，存储原理，功能，特点</strong></h2><p>概念：ES是一个基于lucene构建的，分布式的，RESTful的开源全文搜索引擎。<br>存储原理：数据按照Index – Type – Document – 字段四级存储，其中Index对应数据库，Type对应表，Document为搜索的原子单位，包含一个或多个容器，基于JSON表示。字段是指JSON中的每一项组成，类似于数据库中的行/列。Mapping是文档分析过滤后的结果，根据用户自定义，将某些文字过滤掉，类似于表结构定义DDL？？。同时ES也和分布式数据库一样，支持shard的replication。<br>功能：<br>1、分布式的搜索引擎和数据分析引擎<br>2、全文检索，结构化检索，数据分析。<br>3、对海量数据进行近实时的处理<br>特点：<br>1、可以作为分布式集群处理PB级别的数据，也可单机使用。<br>2、不是特有技术，而是将分布式+全文搜索（lucene) + 数据分析合并在一起。<br>3、操作简单，作为传统数据库的补充，提供了数据库所不具备的很多功能。</p><h2 id="项目中哪里使用到了ES-如何使用"><a href="#项目中哪里使用到了ES-如何使用" class="headerlink" title="项目中哪里使用到了ES,如何使用"></a><strong>项目中哪里使用到了ES,如何使用</strong></h2><p>在进行帖子搜索时，使用到了ES。可用Repository和Template两种方式，由于Repository搜索到的结果（直接返回的post类，方便）没有高亮标签（why），所以使用了template方式重写了mapResults函数，获得了带有高亮标签的post。<br>使用消息队列（kafka）的方式，实现发帖/删帖后ES数据库的自动更新。<br>搜索：定义SearchQuery，确定搜素内容，排序方式，高亮等。接着使用elasticTemplate.queryForPage方法，需要重写mapResults函数，得到高亮数据。</p><h2 id="项目中使用到了SpringSecurity在哪些地方？"><a href="#项目中使用到了SpringSecurity在哪些地方？" class="headerlink" title="项目中使用到了SpringSecurity在哪些地方？"></a><strong>项目中使用到了SpringSecurity在哪些地方？</strong></h2><p>重构了用户权限控制（之前用的拦截器）</p><h2 id="怎样统计网站UA和DAU"><a href="#怎样统计网站UA和DAU" class="headerlink" title="怎样统计网站UA和DAU"></a><strong>怎样统计网站UA和DAU</strong></h2><p>使用Redis的高级数据结构：<br>HyperLogLog：超级日志，统计独立整数个数。统计UA（独立访问）时，以日期为 rediskey ，将客户端IP　add 到HyperLogLog中（redisTemplate.opsForHyperLogLog().add(redisKey, i);）<br>Bitmap：位图，比如365天的签到，只需要３６５／８个字节的大小。统计DAU（日活跃用户）时，以日期为 rediskey ，以用户ID作为位（在数据中的位置），用 or 操作，既可以方便的统计一段时间内的注册用户访问人数。</p><h2 id="什么是Quartz，特点，专业术语，项目应用"><a href="#什么是Quartz，特点，专业术语，项目应用" class="headerlink" title="什么是Quartz，特点，专业术语，项目应用"></a><strong>什么是Quartz，特点，专业术语，项目应用</strong></h2><p>概念：quartz是一个开源项目，完全基于java实现。是一个优秀的开源调度框架。<br>特点：<br>1，强大的调度功能，例如支持丰富多样的调度方法<br>2，灵活的应用方式，例如支持任务和调度的多种组合方式<br>3，分布式和集群能力<br>专业术语：<br>scheduler：任务调度器 ， scheduler是一个计划调度器容器，容器里面有众多的JobDetail和trigger，当容器启动后，里面的每个JobDetail都会根据trigger按部就班自动去执行<br>trigger：触发器，用于定义任务调度时间规则<br>job：任务，即被调度的任务， 主要有两种类型的 job：无状态的（stateless）和有状态的（stateful）。一个 job 可以被多个 trigger 关联，但是一个 trigger 只能关联一个 job<br>misfire：本来应该被执行但实际没有被执行的任务调度<br>项目应用：定时的统计帖子分数（如何设置定时任务和trigger）</p><h2 id="什么是Caffeine，如何缓存，项目应用"><a href="#什么是Caffeine，如何缓存，项目应用" class="headerlink" title="什么是Caffeine，如何缓存，项目应用"></a><strong>什么是Caffeine，如何缓存，项目应用</strong></h2><p>概念：Caffeine 是一个基于Java 8的高性能本地缓存框架<br>初始化cache：缓存保存的对象，使用Caffeine.newBuilder()创建，创建时设置缓存大小，过期时间，缓存未命中时的加载方式。<br>为什么只缓存热度帖子？答：因为不会经常变。</p><p><strong>文章转载于：</strong> 原文链接：<a href="https://blog.csdn.net/weixin_48610702/article/details/115859656">https://blog.csdn.net/weixin_48610702/article/details/115859656</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 后端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个前后端分离博客网站的总结</title>
      <link href="/posts/1a4e5d6d.html"/>
      <url>/posts/1a4e5d6d.html</url>
      
        <content type="html"><![CDATA[<h1 id="jwt的使用"><a href="#jwt的使用" class="headerlink" title="jwt的使用"></a>jwt的使用</h1><ul><li>jwt + redis 使用token令牌的登录，访问认证速度快，实现session共享，安全性较高。 redis做了token令牌和用户信息的对应管理。1. 访问接口token验证【保存在客户端，避免跨站请求伪造CSRF（Cross-site request forgery）】，进一步增加了安全性 2. 登录用户做了缓存 3. 灵活控制用户的过期时间（可以续期，踢掉线等）</li></ul><blockquote><p>jwt 可以生成 一个加密的token，做为用户登录的令牌，当用户登录成功之后，发放给客户端。 当请求需要登录的资源或者接口的时候，将token携带，后端验证token是否合法。</p><p>首先在登陆之前在redis数据库中对数据进行查询，看是否存在该条数据，如果不存在的话，就去数据库查找，然后在查找到之后，在正常登录的时候将数据存储到redis中，当然这个存储信息的键值对也就是在redis查询的那个数据，然后下次如果再次执行访问的时候，在redis中就有了此数据，进而提高了访问的效率。细节：存储用户的登录信息，存储在redis中的时候使用的是hash数据结构，【hash数据结构其实就是，对应的键值对的值是一个字典类型。】此时就可以将用户携带的唯一标识作为值的键，将用户的其他某个信息作为该键的值存储起来。</p><p>private RedisTemplate<String, String> redisTemplate;<br> redisTemplate.opsForValue().set(“TOKEN_”+token, JSON.toJSONString(sysUser),1, TimeUnit.DAYS);</p></blockquote><h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><ul><li><strong>ThreadLocal</strong> 本地线程变量保存用户信息副本到每一个线程中【线程封闭，不会出现线程并发安全问题】。在请求的线程之内，可以随时获取登录的用户，在使用完ThreadLocal之后，<strong>做了对value的删除，防止了内存泄漏。</strong></li></ul><p>【内存泄露】</p><blockquote><p>ThreadLocalMap 为 ThreadLocal 的一个静态内部类，里面定义了Entry 来保存数据。而且是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。</p><p>如果 key threadlocal 为 null 了，这个 entry 就可以清除了。</p><p>ThreadLocalMap中的key为ThreadLocal的弱引用，当key为null时，ThreadLocal会被当成垃圾回收 。</p><p>//首先获取当前线程对象<br> Thread t = Thread.currentThread();<br> //获取线程中变量 ThreadLocal.ThreadLocalMap<br> ThreadLocalMap map = getMap(t); //弱引用<br>虽然ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。</p></blockquote><ul><li>线程安全 update table set value = [newValue] where id=[xx] and value=[oldValue]</li></ul><blockquote><p><strong>CAS</strong>：CAS是Compare And Swap的简称，即：比较并交换。这是当前的处理器基本都支持的一种指令。每个CAS指令包括三个运算符，一个内存地址V，一个期望值A和一个新值B，CAS指令执行的时候是去判断这个地址V上的值和期望值A是否相等，相等则将地址V上的值修改为新值B，不等则不作任何操作。CAS操作实际实现是在一个循环中不断执行CAS指令，直到成功为止。</p></blockquote><ul><li><p>线程池@<strong>Async</strong> 对当前的主业务流程无影响的操作，放入线程池执行。比如加载文章详情和文章阅读数更新，这两个业务流程需要分开执行，互不影响。</p></li><li><p>文章发布 @Transactional 事务处理。</p></li></ul><h1 id="统一日志操作"><a href="#统一日志操作" class="headerlink" title="统一日志操作"></a>统一日志操作</h1><ul><li><p>统一日志记录,通过定义切点、实现切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.zzh.common.aop.LogAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">log</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> point.proceed();</span><br><span class="line">        <span class="comment">//执行时长(毫秒)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis() - beginTime;</span><br><span class="line">        <span class="comment">//保存日志</span></span><br><span class="line">        recordLog(point, time);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="统一异常操作"><a href="#统一异常操作" class="headerlink" title="统一异常操作"></a>统一异常操作</h1></li><li><p>统一异常处，@ControllerAdvice 对所有带Controller注解的类实施异常拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对加了@Controller注解的方法进行拦截处理 aop</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.fail(-<span class="number">999</span>,<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="统一登陆操作"><a href="#统一登陆操作" class="headerlink" title="统一登陆操作"></a>统一登陆操作</h1></li><li><p>统一登录拦截，先写Handler拦截类，再到WebConfig类配置生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(StringUtils.isBlank(token))&#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> Result.fail(ErrorCode.NO_LOGIN.getCode(), <span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">    <span class="comment">//设置浏览器识别返回的是json</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">    response.getWriter().print(JSON.toJSONString(result));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SysUser</span> <span class="variable">sysUser</span> <span class="operator">=</span> loginService.checkToken(token);</span><br><span class="line"><span class="keyword">if</span> (sysUser == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> Result.fail(ErrorCode.NO_LOGIN.getCode(), <span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">    response.getWriter().print(JSON.toJSONString(result));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中事务内容总结</title>
      <link href="/posts/31feb151.html"/>
      <url>/posts/31feb151.html</url>
      
        <content type="html"><![CDATA[<h1 id="事务的总结"><a href="#事务的总结" class="headerlink" title="事务的总结"></a>事务的总结</h1><p><strong>事务特性</strong>： ①原子性：要么都成功，要么都失败，回滚。②一致性 ③隔离性 ④持久性。</p><p><strong>事务并发问题</strong>：</p><p>① 脏读：一个事务读取了另一个事务未提交的数据。</p><p>② 不可重复读：一个事务多次查询却返回了不同的结果。这是由于在查询间隔，另一事务修改了数据并进行了提交。强调 读–读。</p><p>③ 幻读：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的数据。例如：select某记录是否存在，不存在，准备插入此纪录，但执行insert时发现该记录已经存在，无法插入，此时就发生了幻读。强调 读–写。</p><p><strong>事务隔离级别</strong>：</p><p>① READ-UNCOMMITTED (读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p>② READ-COMMITTED (读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><p>③ REPEATABLE-READ (可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p>④ SERIALIZABLE (可串行化)： 最高的隔离级别，完全服从ACID原则。所有的事务依次逐个执行，事务间完全互不干扰，可以防止脏读、不可重复读以及幻读。</p><p><strong>Mysql 默认采用的 REPEATABLE_READ （可重复读）隔离级别。</strong> 事务隔离机制的实现基于锁机制和并发调度。 其中并发调度使用的是MVCC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p><strong>++MVCC++</strong><br>主要为了提高数据库并发性能，处理读写冲突问题。</p><p>原理：通过保存数据在某个时间点的快照来实现的。也就是说不管要执行多长时间，每个事务看到的数据都是一致的。</p><p>MVCC可以解决脏读、不可重复读、部分幻读问题。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo页面操作</title>
      <link href="/posts/53463b06.html"/>
      <url>/posts/53463b06.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、创建文章"><a href="#一、创建文章" class="headerlink" title="一、创建文章"></a>一、创建文章</h1><p>在站点文件夹中打开git bash，输入如下命令创建文章，其中title为文章的标题<br><div class="note simple"><p>$ hexo new “my-first-blog”</p></div><br>此时就会在source/_post文件夹中创建了一个文件，命名为：my-first-blog.md，而这个文件就是将要发布到网站上的原始文件，记录文章内容，以下我们将要在这个文件中写下我们的第一篇博客</p><h1 id="二、编写文章（基于Markdown）"><a href="#二、编写文章（基于Markdown）" class="headerlink" title="二、编写文章（基于Markdown）"></a>二、编写文章（基于Markdown）</h1><h2 id="1-Markdown简介"><a href="#1-Markdown简介" class="headerlink" title="1.Markdown简介"></a>1.Markdown简介</h2><p>但是在我们正式写下我们文章的第一个文字时，我们需要了解一下什么是 Markdown：</p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式</p><p>基于Markdown的简洁性，它已经成为了目前世界上最流行的用于书写博客的语言。</p><h2 id="2-Markdown语法"><a href="#2-Markdown语法" class="headerlink" title="2. Markdown语法"></a>2. Markdown语法</h2><p>在了解Markdown 语法之前，博主十分强烈推荐csdn编辑器markdown,十分方便好用，还可以实时预览，如果有更好的编辑器可以推荐给我哦~</p><h3 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h3><p>Markdown 语法：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.# 一级标题</span><br><span class="line">2.## 二级标题</span><br><span class="line">3.### 三级标题</span><br><span class="line">4.#### 四级标题</span><br><span class="line">5.##### 五级标题</span><br><span class="line">6.###### 六级标题</span><br></pre></td></tr></table></figure></p><h3 id="（2）粗体、斜体、删除线和下划线"><a href="#（2）粗体、斜体、删除线和下划线" class="headerlink" title="（2）粗体、斜体、删除线和下划线"></a>（2）粗体、斜体、删除线和下划线</h3><p>Markdown语法：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.* 斜体 *</span><br><span class="line">2.** 粗体 **</span><br><span class="line">3.<span class="strong">*** 加粗斜体 **</span>*</span><br><span class="line">4.~~ 删除线 ~~</span><br><span class="line"></span><br><span class="line">Typora快捷键</span><br><span class="line">ctrl+b: 粗体</span><br></pre></td></tr></table></figure></p><h3 id="（3）引用快"><a href="#（3）引用快" class="headerlink" title="（3）引用快"></a>（3）引用快</h3><p>Markdown 语法：</p><p>‘&gt;’文字引用<br>Typora快捷键： ctrl+shift +q</p><h3 id="（4）代码块"><a href="#（4）代码块" class="headerlink" title="（4）代码块"></a>（4）代码块</h3><p>Markdown语法：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.``行内代码</span><br><span class="line">2.···</span><br><span class="line">3.多行代码</span><br><span class="line">4.多行代码</span><br><span class="line">5.<span class="code">```</span></span><br></pre></td></tr></table></figure></p><h3 id="（5）代码块"><a href="#（5）代码块" class="headerlink" title="（5）代码块"></a>（5）代码块</h3><p>Markdown语法：<br>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(tab), 另一种是利用英文“`”符号（一般在ESC键下方，和~同一个键）包裹代码。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line">\```</span><br><span class="line">ps：记得去掉\</span><br></pre></td></tr></table></figure></p><h3 id="（6）分割线"><a href="#（6）分割线" class="headerlink" title="（6）分割线"></a>（6）分割线</h3><p>Markdown语法：<br>1.方法一：—</p><p>2.方法二：+++</p><p>3.方法三：<em>*</em><br>使用以上三种方法都可以</p><h3 id="（7）列表"><a href="#（7）列表" class="headerlink" title="（7）列表"></a>（7）列表</h3><p>Markdown语法：<br>1 有序列表项</p><p>*无序列表项</p><p>+无序列表项</p><h3 id="（8）表格"><a href="#（8）表格" class="headerlink" title="（8）表格"></a>（8）表格</h3><p>Markdown语法：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure></p><h3 id="（9）超链接"><a href="#（9）超链接" class="headerlink" title="（9）超链接"></a>（9）超链接</h3><p>Markdown语法：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure></p><p>好了，常用的 Markdown 语法至此我们已经基本学习完毕了,然后我们就可以根据这些语法去书写我们的博客内容啦,下面再提供几个比较高级的玩法：<br>(1）模板设置<br>当我们使用命令hexo new “title” 去创建我们的文章时，Hexo 会根据 /scaffolds/post.md 文件对新建文件进行初始化，换言之，/scaffolds/post.md 文件就是创建新文章的模板，所以我们可以修改它来适应自己的写作习惯，一个简单的示例如下：</p><p>(2）头部设置<br>在每一篇博客文章的开头都会有对文章的说明文字，叫做 文章头部，文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以对文章添加标签、分类等，一个简单的示例如下</p><p>注意，属性和属性值之间必须有一个空格，否则会解析错误<br>(3）首页显示<br>在 Hexo 框架搭建的博客网站首页会显示文章的内容（默认显示文章的全部内容），如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简，只需在文章中使用 <span id="more"></span>标志，表示只会显示标志前面的内容</p><p>三、部署发布<br>在站点文件夹中打开 git bash，输入如下命令部署和发布文章<br><div class="note simple"><p>$ hexo g</p></div><br>更推荐的操作是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  // Git BASH终端</span><br><span class="line">hexo clean; hexo generate; hexo deploy  // VSCODE终端</span><br></pre></td></tr></table></figure><br>建议：在使用命令 hexo g 部署之后，可以先使用 hexo s运行本地站点，在浏览器输入地址<a href="http://lacolhost:4000/">http://lacolhost:4000/</a><br>来查看运行结果，检查没有错误后再使用命令hexo d发布</p><h1 id="三、更多参考"><a href="#三、更多参考" class="headerlink" title="三、更多参考"></a>三、更多参考</h1><p>Markdown语法图文全面详解(10分钟学会)：<a href="https://blog.csdn.net/u014061630/article/details/81359144">https://blog.csdn.net/u014061630/article/details/81359144</a><br>Markdown语法与外挂标签写法汇总：<a href="https://www.fomal.cc/posts/2013454d.html">https://www.fomal.cc/posts/2013454d.html</a></p><hr><p>文章参考：<a href="https://blog.csdn.net/wsmrzx/article/details/81478945">https://blog.csdn.net/wsmrzx/article/details/81478945</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒速五厘米</title>
      <link href="/posts/8526d39f.html"/>
      <url>/posts/8526d39f.html</url>
      
        <content type="html"><![CDATA[<h2 id="樱花飘落的速度是秒速五厘米"><a href="#樱花飘落的速度是秒速五厘米" class="headerlink" title="樱花飘落的速度是秒速五厘米"></a>樱花飘落的速度是秒速五厘米</h2><hr><p>在这几年里，我光顾着低头前行，只想着得到那无法得到的东西，但是又不知道那究竟是什么。而这个不知从何而来的想法逐渐地变成一种压迫，让我只能靠不停工作来解脱。等我惊觉之时，逐渐僵硬的心只能感觉到痛苦。然后在一天早上，我发现曾经那刻骨铭心的感情——已然完全失却。</p><hr><p>在这个瞬间。我似乎明白了‘永远’、‘心’和‘灵魂’的意义之所在，强烈的情感让我想将这十三年所经历的全部都与她分享。然后在下一个瞬间——却又悲伤得无法抑制。那是因为，我不知该如何珍藏明里的这份温暖，也不知该将她的灵魂带往何处去。我清楚地明白，我们无法保证将来能永远在一起。横亘在我们面前的是那沉重的人生与漫长的时间，让人不由得产生一种无力感</p><hr><p>听说，樱花花瓣飘落的速度，是每秒5厘米… 思念的距离到底有多远…… 樱花下落的速度是秒速5厘米。如果樱花下落时是有声音的，你会不会听到我对你的思念。</p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/posts/5c2fafc7.html"/>
      <url>/posts/5c2fafc7.html</url>
      
        <content type="html"><![CDATA[<h2 id="这是一次测试"><a href="#这是一次测试" class="headerlink" title="这是一次测试"></a>这是一次测试</h2><p>也许很快就把这个删掉了，也许也不会删掉吧</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
